{"ast":null,"code":"import { isUndefined, throwError, isNullOrUndefined, extend, isBlazor, getValue } from '../util';\nimport { defaultCurrencyCode } from '../internationalization';\nimport { IntlBase as base } from './intl-base';\nimport { ParserBase as parser } from './parser-base';\nvar errorText = {\n  'ms': 'minimumSignificantDigits',\n  'ls': 'maximumSignificantDigits',\n  'mf': 'minimumFractionDigits',\n  'lf': 'maximumFractionDigits'\n};\nvar integerError = 'minimumIntegerDigits';\nvar percentSign = 'percentSign';\nvar minusSign = 'minusSign';\nvar spaceRegex = /\\s/;\nvar mapper = ['infinity', 'nan', 'group', 'decimal', 'exponential'];\nvar infinity = 'infinity';\nvar nan = 'nan';\n/**\r\n * Module for number formatting.\r\n *\r\n * @private\r\n */\nvar NumberFormat = /** @class */function () {\n  function NumberFormat() {}\n  /**\r\n   * Returns the formatter function for given skeleton.\r\n   *\r\n   * @param {string} culture -  Specifies the culture name to be which formatting.\r\n   * @param {NumberFormatOptions} option - Specific the format in which number  will format.\r\n   * @param {Object} cldr - Specifies the global cldr data collection.\r\n   * @returns {Function} ?\r\n   */\n  NumberFormat.numberFormatter = function (culture, option, cldr) {\n    var _this = this;\n    var fOptions = extend({}, option);\n    var cOptions = {};\n    var dOptions = {};\n    var symbolPattern;\n    var dependable = base.getDependables(cldr, culture, '', true);\n    var numObject = dependable.numericObject;\n    dOptions.numberMapper = isBlazor() ? extend({}, numObject) : parser.getNumberMapper(dependable.parserObject, parser.getNumberingSystem(cldr), true);\n    dOptions.currencySymbol = isBlazor() ? getValue('currencySymbol', numObject) : base.getCurrencySymbol(dependable.numericObject, fOptions.currency || defaultCurrencyCode, option.altSymbol);\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    dOptions.percentSymbol = isBlazor() ? getValue('numberSymbols.percentSign', numObject) : dOptions.numberMapper.numberSymbols[\"\" + percentSign];\n    dOptions.minusSymbol = isBlazor() ? getValue('numberSymbols.minusSign', numObject) : dOptions.numberMapper.numberSymbols[\"\" + minusSign];\n    var symbols = dOptions.numberMapper.numberSymbols;\n    if (option.format && !base.formatRegex.test(option.format)) {\n      cOptions = base.customFormat(option.format, dOptions, dependable.numericObject);\n    } else {\n      extend(fOptions, base.getProperNumericSkeleton(option.format || 'N'));\n      fOptions.isCurrency = fOptions.type === 'currency';\n      fOptions.isPercent = fOptions.type === 'percent';\n      if (!isBlazor()) {\n        symbolPattern = base.getSymbolPattern(fOptions.type, dOptions.numberMapper.numberSystem, dependable.numericObject, fOptions.isAccount);\n      }\n      fOptions.groupOne = this.checkValueRange(fOptions.maximumSignificantDigits, fOptions.minimumSignificantDigits, true);\n      this.checkValueRange(fOptions.maximumFractionDigits, fOptions.minimumFractionDigits, false, true);\n      if (!isUndefined(fOptions.fractionDigits)) {\n        fOptions.minimumFractionDigits = fOptions.maximumFractionDigits = fOptions.fractionDigits;\n      }\n      if (isUndefined(fOptions.useGrouping)) {\n        fOptions.useGrouping = true;\n      }\n      if (fOptions.isCurrency && !isBlazor()) {\n        symbolPattern = symbolPattern.replace(/\\u00A4/g, base.defaultCurrency);\n      }\n      if (!isBlazor()) {\n        var split = symbolPattern.split(';');\n        cOptions.nData = base.getFormatData(split[1] || '-' + split[0], true, dOptions.currencySymbol);\n        cOptions.pData = base.getFormatData(split[0], false, dOptions.currencySymbol);\n        if (fOptions.useGrouping) {\n          fOptions.groupSeparator = symbols[mapper[2]];\n          fOptions.groupData = this.getGroupingDetails(split[0]);\n        }\n      } else {\n        cOptions.nData = extend({}, {}, getValue(fOptions.type + 'nData', numObject));\n        cOptions.pData = extend({}, {}, getValue(fOptions.type + 'pData', numObject));\n        if (fOptions.type === 'currency' && option.currency) {\n          base.replaceBlazorCurrency([cOptions.pData, cOptions.nData], dOptions.currencySymbol, option.currency);\n        }\n      }\n      var minFrac = isUndefined(fOptions.minimumFractionDigits);\n      if (minFrac) {\n        fOptions.minimumFractionDigits = cOptions.nData.minimumFraction;\n      }\n      if (isUndefined(fOptions.maximumFractionDigits)) {\n        var mval = cOptions.nData.maximumFraction;\n        fOptions.maximumFractionDigits = isUndefined(mval) && fOptions.isPercent ? 0 : mval;\n      }\n      var mfrac = fOptions.minimumFractionDigits;\n      var lfrac = fOptions.maximumFractionDigits;\n      if (!isUndefined(mfrac) && !isUndefined(lfrac)) {\n        if (mfrac > lfrac) {\n          fOptions.maximumFractionDigits = mfrac;\n        }\n      }\n    }\n    extend(cOptions.nData, fOptions);\n    extend(cOptions.pData, fOptions);\n    return function (value) {\n      if (isNaN(value)) {\n        return symbols[mapper[1]];\n      } else if (!isFinite(value)) {\n        return symbols[mapper[0]];\n      }\n      return _this.intNumberFormatter(value, cOptions, dOptions, option);\n    };\n  };\n  /**\r\n   * Returns grouping details for the pattern provided\r\n   *\r\n   * @param {string} pattern ?\r\n   * @returns {GroupDetails} ?\r\n   */\n  NumberFormat.getGroupingDetails = function (pattern) {\n    var ret = {};\n    var match = pattern.match(base.negativeDataRegex);\n    if (match && match[4]) {\n      var pattern_1 = match[4];\n      var p = pattern_1.lastIndexOf(',');\n      if (p !== -1) {\n        var temp = pattern_1.split('.')[0];\n        ret.primary = temp.length - p - 1;\n        var s = pattern_1.lastIndexOf(',', p - 1);\n        if (s !== -1) {\n          ret.secondary = p - 1 - s;\n        }\n      }\n    }\n    return ret;\n  };\n  /**\r\n   * Returns if the provided integer range is valid.\r\n   *\r\n   * @param {number} val1 ?\r\n   * @param {number} val2 ?\r\n   * @param {boolean} checkbothExist ?\r\n   * @param {boolean} isFraction ?\r\n   * @returns {boolean} ?\r\n   */\n  NumberFormat.checkValueRange = function (val1, val2, checkbothExist, isFraction) {\n    var decide = isFraction ? 'f' : 's';\n    var dint = 0;\n    var str1 = errorText['l' + decide];\n    // eslint-disable-next-line\n    var str2 = errorText['m' + decide];\n    if (!isUndefined(val1)) {\n      this.checkRange(val1, str1, isFraction);\n      dint++;\n    }\n    if (!isUndefined(val2)) {\n      this.checkRange(val2, str2, isFraction);\n      dint++;\n    }\n    if (dint === 2) {\n      if (val1 < val2) {\n        throwError(str2 + 'specified must be less than the' + str1);\n      } else {\n        return true;\n      }\n    } else if (checkbothExist && dint === 1) {\n      throwError('Both' + str2 + 'and' + str2 + 'must be present');\n    }\n    return false;\n  };\n  /**\r\n   * Check if the provided fraction range is valid\r\n   *\r\n   * @param {number} val ?\r\n   * @param {string} text ?\r\n   * @param {boolean} isFraction ?\r\n   * @returns {void} ?\r\n   */\n  NumberFormat.checkRange = function (val, text, isFraction) {\n    var range = isFraction ? [0, 20] : [1, 21];\n    if (val < range[0] || val > range[1]) {\n      throwError(text + 'value must be within the range' + range[0] + 'to' + range[1]);\n    }\n  };\n  /**\r\n   * Returns formatted numeric string for provided formatting options\r\n   *\r\n   * @param {number} value ?\r\n   * @param {base.GenericFormatOptions} fOptions ?\r\n   * @param {CommonOptions} dOptions ?\r\n   * @returns {string} ?\r\n   */\n  NumberFormat.intNumberFormatter = function (value, fOptions, dOptions, option) {\n    var curData;\n    if (isUndefined(fOptions.nData.type)) {\n      return undefined;\n    } else {\n      if (value < 0) {\n        value = value * -1;\n        curData = fOptions.nData;\n      } else if (value === 0) {\n        curData = fOptions.zeroData || fOptions.pData;\n      } else {\n        curData = fOptions.pData;\n      }\n      var fValue = '';\n      if (curData.isPercent) {\n        value = value * 100;\n      }\n      if (curData.groupOne) {\n        fValue = this.processSignificantDigits(value, curData.minimumSignificantDigits, curData.maximumSignificantDigits);\n      } else {\n        fValue = this.processFraction(value, curData.minimumFractionDigits, curData.maximumFractionDigits, option);\n        if (curData.minimumIntegerDigits) {\n          fValue = this.processMinimumIntegers(fValue, curData.minimumIntegerDigits);\n        }\n        if (dOptions.isCustomFormat && curData.minimumFractionDigits < curData.maximumFractionDigits && /\\d+\\.\\d+/.test(fValue)) {\n          var temp = fValue.split('.');\n          var decimalPart = temp[1];\n          var len = decimalPart.length;\n          for (var i = len - 1; i >= 0; i--) {\n            if (decimalPart[\"\" + i] === '0' && i >= curData.minimumFractionDigits) {\n              decimalPart = decimalPart.slice(0, i);\n            } else {\n              break;\n            }\n          }\n          fValue = temp[0] + '.' + decimalPart;\n        }\n      }\n      if (curData.type === 'scientific') {\n        fValue = value.toExponential(curData.maximumFractionDigits);\n        fValue = fValue.replace('e', dOptions.numberMapper.numberSymbols[mapper[4]]);\n      }\n      fValue = fValue.replace('.', dOptions.numberMapper.numberSymbols[mapper[3]]);\n      fValue = curData.format === \"#,###,,;(#,###,,)\" ? this.customPivotFormat(parseInt(fValue)) : fValue;\n      if (curData.useGrouping) {\n        /* eslint-disable  @typescript-eslint/no-explicit-any */\n        fValue = this.groupNumbers(fValue, curData.groupData.primary, curData.groupSeparator || ',', dOptions.numberMapper.numberSymbols[mapper[3]] || '.', curData.groupData.secondary);\n      }\n      fValue = parser.convertValueParts(fValue, base.latnParseRegex, dOptions.numberMapper.mapper);\n      if (curData.nlead === 'N/A') {\n        return curData.nlead;\n      } else {\n        if (fValue === '0' && option && option.format === '0') {\n          return fValue + curData.nend;\n        }\n        return curData.nlead + fValue + curData.nend;\n      }\n    }\n  };\n  /**\r\n   * Returns significant digits processed numeric string\r\n   *\r\n   * @param {number} value ?\r\n   * @param {number} min ?\r\n   * @param {number} max ?\r\n   * @returns {string} ?\r\n   */\n  NumberFormat.processSignificantDigits = function (value, min, max) {\n    var temp = value + '';\n    var tn;\n    var length = temp.length;\n    if (length < min) {\n      return value.toPrecision(min);\n    } else {\n      temp = value.toPrecision(max);\n      tn = +temp;\n      return tn + '';\n    }\n  };\n  /**\r\n   * Returns grouped numeric string\r\n   *\r\n   * @param {string} val ?\r\n   * @param {number} level1 ?\r\n   * @param {string} sep ?\r\n   * @param {string} decimalSymbol ?\r\n   * @param {number} level2 ?\r\n   * @returns {string} ?\r\n   */\n  NumberFormat.groupNumbers = function (val, level1, sep, decimalSymbol, level2) {\n    var flag = !isNullOrUndefined(level2) && level2 !== 0;\n    var split = val.split(decimalSymbol);\n    var prefix = split[0];\n    var length = prefix.length;\n    var str = '';\n    while (length > level1) {\n      str = prefix.slice(length - level1, length) + (str.length ? sep + str : '');\n      length -= level1;\n      if (flag) {\n        level1 = level2;\n        flag = false;\n      }\n    }\n    split[0] = prefix.slice(0, length) + (str.length ? sep : '') + str;\n    return split.join(decimalSymbol);\n  };\n  /**\r\n   * Returns fraction processed numeric string\r\n   *\r\n   * @param {number} value ?\r\n   * @param {number} min ?\r\n   * @param {number} max ?\r\n   * @returns {string} ?\r\n   */\n  NumberFormat.processFraction = function (value, min, max, option) {\n    var temp = (value + '').split('.')[1];\n    var length = temp ? temp.length : 0;\n    if (min && length < min) {\n      var ret = '';\n      if (length === 0) {\n        ret = value.toFixed(min);\n      } else {\n        ret += value;\n        for (var j = 0; j < min - length; j++) {\n          ret += '0';\n        }\n        return ret;\n      }\n      return value.toFixed(min);\n    } else if (!isNullOrUndefined(max) && (length > max || max === 0)) {\n      return value.toFixed(max);\n    }\n    var str = value + '';\n    if (str[0] === '0' && option && option.format === '###.00') {\n      str = str.slice(1);\n    }\n    return str;\n  };\n  /**\r\n   * Returns integer processed numeric string\r\n   *\r\n   * @param {string} value ?\r\n   * @param {number} min ?\r\n   * @returns {string} ?\r\n   */\n  NumberFormat.processMinimumIntegers = function (value, min) {\n    var temp = value.split('.');\n    var lead = temp[0];\n    var len = lead.length;\n    if (len < min) {\n      for (var i = 0; i < min - len; i++) {\n        lead = '0' + lead;\n      }\n      temp[0] = lead;\n    }\n    return temp.join('.');\n  };\n  /**\r\n   * Returns custom format for pivot table\r\n   *\r\n   * @param {number} value ?\r\n   */\n  NumberFormat.customPivotFormat = function (value) {\n    if (value >= 500000) {\n      value /= 1000000;\n      var _a = value.toString().split(\".\"),\n        integer = _a[0],\n        decimal = _a[1];\n      return decimal && +decimal.substring(0, 1) >= 5 ? Math.ceil(value).toString() : Math.floor(value).toString();\n    }\n    return \"\";\n  };\n  return NumberFormat;\n}();\nexport { NumberFormat };","map":{"version":3,"names":["isUndefined","throwError","isNullOrUndefined","extend","isBlazor","getValue","defaultCurrencyCode","IntlBase","base","ParserBase","parser","errorText","integerError","percentSign","minusSign","spaceRegex","mapper","infinity","nan","NumberFormat","numberFormatter","culture","option","cldr","_this","fOptions","cOptions","dOptions","symbolPattern","dependable","getDependables","numObject","numericObject","numberMapper","getNumberMapper","parserObject","getNumberingSystem","currencySymbol","getCurrencySymbol","currency","altSymbol","percentSymbol","numberSymbols","minusSymbol","symbols","format","formatRegex","test","customFormat","getProperNumericSkeleton","isCurrency","type","isPercent","getSymbolPattern","numberSystem","isAccount","groupOne","checkValueRange","maximumSignificantDigits","minimumSignificantDigits","maximumFractionDigits","minimumFractionDigits","fractionDigits","useGrouping","replace","defaultCurrency","split","nData","getFormatData","pData","groupSeparator","groupData","getGroupingDetails","replaceBlazorCurrency","minFrac","minimumFraction","mval","maximumFraction","mfrac","lfrac","value","isNaN","isFinite","intNumberFormatter","pattern","ret","match","negativeDataRegex","pattern_1","p","lastIndexOf","temp","primary","length","s","secondary","val1","val2","checkbothExist","isFraction","decide","dint","str1","str2","checkRange","val","text","range","curData","undefined","zeroData","fValue","processSignificantDigits","processFraction","minimumIntegerDigits","processMinimumIntegers","isCustomFormat","decimalPart","len","i","slice","toExponential","customPivotFormat","parseInt","groupNumbers","convertValueParts","latnParseRegex","nlead","nend","min","max","tn","toPrecision","level1","sep","decimalSymbol","level2","flag","prefix","str","join","toFixed","j","lead","_a","toString","integer","decimal","substring","Math","ceil","floor"],"sources":["C:/Users/User/Desktop/ClinicaDentalVersionFinal/Proyecto-Clinica-Dental/donto-react/node_modules/@syncfusion/ej2-base/src/intl/number-formatter.js"],"sourcesContent":["import { isUndefined, throwError, isNullOrUndefined, extend, isBlazor, getValue } from '../util';\r\nimport { defaultCurrencyCode } from '../internationalization';\r\nimport { IntlBase as base } from './intl-base';\r\nimport { ParserBase as parser } from './parser-base';\r\nvar errorText = {\r\n    'ms': 'minimumSignificantDigits',\r\n    'ls': 'maximumSignificantDigits',\r\n    'mf': 'minimumFractionDigits',\r\n    'lf': 'maximumFractionDigits'\r\n};\r\nvar integerError = 'minimumIntegerDigits';\r\nvar percentSign = 'percentSign';\r\nvar minusSign = 'minusSign';\r\nvar spaceRegex = /\\s/;\r\nvar mapper = ['infinity', 'nan', 'group', 'decimal', 'exponential'];\r\nvar infinity = 'infinity';\r\nvar nan = 'nan';\r\n/**\r\n * Module for number formatting.\r\n *\r\n * @private\r\n */\r\nvar NumberFormat = /** @class */ (function () {\r\n    function NumberFormat() {\r\n    }\r\n    /**\r\n     * Returns the formatter function for given skeleton.\r\n     *\r\n     * @param {string} culture -  Specifies the culture name to be which formatting.\r\n     * @param {NumberFormatOptions} option - Specific the format in which number  will format.\r\n     * @param {Object} cldr - Specifies the global cldr data collection.\r\n     * @returns {Function} ?\r\n     */\r\n    NumberFormat.numberFormatter = function (culture, option, cldr) {\r\n        var _this = this;\r\n        var fOptions = extend({}, option);\r\n        var cOptions = {};\r\n        var dOptions = {};\r\n        var symbolPattern;\r\n        var dependable = base.getDependables(cldr, culture, '', true);\r\n        var numObject = dependable.numericObject;\r\n        dOptions.numberMapper = isBlazor() ? extend({}, numObject) :\r\n            parser.getNumberMapper(dependable.parserObject, parser.getNumberingSystem(cldr), true);\r\n        dOptions.currencySymbol = isBlazor() ? getValue('currencySymbol', numObject) : base.getCurrencySymbol(dependable.numericObject, fOptions.currency || defaultCurrencyCode, option.altSymbol);\r\n        /* eslint-disable  @typescript-eslint/no-explicit-any */\r\n        dOptions.percentSymbol = isBlazor() ? getValue('numberSymbols.percentSign', numObject) :\r\n            dOptions.numberMapper.numberSymbols[\"\" + percentSign];\r\n        dOptions.minusSymbol = isBlazor() ? getValue('numberSymbols.minusSign', numObject) :\r\n            dOptions.numberMapper.numberSymbols[\"\" + minusSign];\r\n        var symbols = dOptions.numberMapper.numberSymbols;\r\n        if ((option.format) && !(base.formatRegex.test(option.format))) {\r\n            cOptions = base.customFormat(option.format, dOptions, dependable.numericObject);\r\n        }\r\n        else {\r\n            extend(fOptions, base.getProperNumericSkeleton(option.format || 'N'));\r\n            fOptions.isCurrency = fOptions.type === 'currency';\r\n            fOptions.isPercent = fOptions.type === 'percent';\r\n            if (!isBlazor()) {\r\n                symbolPattern = base.getSymbolPattern(fOptions.type, dOptions.numberMapper.numberSystem, dependable.numericObject, fOptions.isAccount);\r\n            }\r\n            fOptions.groupOne = this.checkValueRange(fOptions.maximumSignificantDigits, fOptions.minimumSignificantDigits, true);\r\n            this.checkValueRange(fOptions.maximumFractionDigits, fOptions.minimumFractionDigits, false, true);\r\n            if (!isUndefined(fOptions.fractionDigits)) {\r\n                fOptions.minimumFractionDigits = fOptions.maximumFractionDigits = fOptions.fractionDigits;\r\n            }\r\n            if (isUndefined(fOptions.useGrouping)) {\r\n                fOptions.useGrouping = true;\r\n            }\r\n            if (fOptions.isCurrency && !isBlazor()) {\r\n                symbolPattern = symbolPattern.replace(/\\u00A4/g, base.defaultCurrency);\r\n            }\r\n            if (!isBlazor()) {\r\n                var split = symbolPattern.split(';');\r\n                cOptions.nData = base.getFormatData(split[1] || '-' + split[0], true, dOptions.currencySymbol);\r\n                cOptions.pData = base.getFormatData(split[0], false, dOptions.currencySymbol);\r\n                if (fOptions.useGrouping) {\r\n                    fOptions.groupSeparator = symbols[mapper[2]];\r\n                    fOptions.groupData = this.getGroupingDetails(split[0]);\r\n                }\r\n            }\r\n            else {\r\n                cOptions.nData = extend({}, {}, getValue(fOptions.type + 'nData', numObject));\r\n                cOptions.pData = extend({}, {}, getValue(fOptions.type + 'pData', numObject));\r\n                if (fOptions.type === 'currency' && option.currency) {\r\n                    base.replaceBlazorCurrency([cOptions.pData, cOptions.nData], dOptions.currencySymbol, option.currency);\r\n                }\r\n            }\r\n            var minFrac = isUndefined(fOptions.minimumFractionDigits);\r\n            if (minFrac) {\r\n                fOptions.minimumFractionDigits = cOptions.nData.minimumFraction;\r\n            }\r\n            if (isUndefined(fOptions.maximumFractionDigits)) {\r\n                var mval = cOptions.nData.maximumFraction;\r\n                fOptions.maximumFractionDigits = isUndefined(mval) && fOptions.isPercent ? 0 : mval;\r\n            }\r\n            var mfrac = fOptions.minimumFractionDigits;\r\n            var lfrac = fOptions.maximumFractionDigits;\r\n            if (!isUndefined(mfrac) && !isUndefined(lfrac)) {\r\n                if (mfrac > lfrac) {\r\n                    fOptions.maximumFractionDigits = mfrac;\r\n                }\r\n            }\r\n        }\r\n        extend(cOptions.nData, fOptions);\r\n        extend(cOptions.pData, fOptions);\r\n        return function (value) {\r\n            if (isNaN(value)) {\r\n                return symbols[mapper[1]];\r\n            }\r\n            else if (!isFinite(value)) {\r\n                return symbols[mapper[0]];\r\n            }\r\n            return _this.intNumberFormatter(value, cOptions, dOptions, option);\r\n        };\r\n    };\r\n    /**\r\n     * Returns grouping details for the pattern provided\r\n     *\r\n     * @param {string} pattern ?\r\n     * @returns {GroupDetails} ?\r\n     */\r\n    NumberFormat.getGroupingDetails = function (pattern) {\r\n        var ret = {};\r\n        var match = pattern.match(base.negativeDataRegex);\r\n        if (match && match[4]) {\r\n            var pattern_1 = match[4];\r\n            var p = pattern_1.lastIndexOf(',');\r\n            if (p !== -1) {\r\n                var temp = pattern_1.split('.')[0];\r\n                ret.primary = (temp.length - p) - 1;\r\n                var s = pattern_1.lastIndexOf(',', p - 1);\r\n                if (s !== -1) {\r\n                    ret.secondary = p - 1 - s;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    /**\r\n     * Returns if the provided integer range is valid.\r\n     *\r\n     * @param {number} val1 ?\r\n     * @param {number} val2 ?\r\n     * @param {boolean} checkbothExist ?\r\n     * @param {boolean} isFraction ?\r\n     * @returns {boolean} ?\r\n     */\r\n    NumberFormat.checkValueRange = function (val1, val2, checkbothExist, isFraction) {\r\n        var decide = isFraction ? 'f' : 's';\r\n        var dint = 0;\r\n        var str1 = errorText['l' + decide];\r\n        // eslint-disable-next-line\r\n        var str2 = errorText['m' + decide];\r\n        if (!isUndefined(val1)) {\r\n            this.checkRange(val1, str1, isFraction);\r\n            dint++;\r\n        }\r\n        if (!isUndefined(val2)) {\r\n            this.checkRange(val2, str2, isFraction);\r\n            dint++;\r\n        }\r\n        if (dint === 2) {\r\n            if (val1 < val2) {\r\n                throwError(str2 + 'specified must be less than the' + str1);\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        else if (checkbothExist && dint === 1) {\r\n            throwError('Both' + str2 + 'and' + str2 + 'must be present');\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Check if the provided fraction range is valid\r\n     *\r\n     * @param {number} val ?\r\n     * @param {string} text ?\r\n     * @param {boolean} isFraction ?\r\n     * @returns {void} ?\r\n     */\r\n    NumberFormat.checkRange = function (val, text, isFraction) {\r\n        var range = isFraction ? [0, 20] : [1, 21];\r\n        if (val < range[0] || val > range[1]) {\r\n            throwError(text + 'value must be within the range' + range[0] + 'to' + range[1]);\r\n        }\r\n    };\r\n    /**\r\n     * Returns formatted numeric string for provided formatting options\r\n     *\r\n     * @param {number} value ?\r\n     * @param {base.GenericFormatOptions} fOptions ?\r\n     * @param {CommonOptions} dOptions ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.intNumberFormatter = function (value, fOptions, dOptions, option) {\r\n        var curData;\r\n        if (isUndefined(fOptions.nData.type)) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            if (value < 0) {\r\n                value = value * -1;\r\n                curData = fOptions.nData;\r\n            }\r\n            else if (value === 0) {\r\n                curData = fOptions.zeroData || fOptions.pData;\r\n            }\r\n            else {\r\n                curData = fOptions.pData;\r\n            }\r\n            var fValue = '';\r\n            if (curData.isPercent) {\r\n                value = value * 100;\r\n            }\r\n            if (curData.groupOne) {\r\n                fValue = this.processSignificantDigits(value, curData.minimumSignificantDigits, curData.maximumSignificantDigits);\r\n            }\r\n            else {\r\n                fValue = this.processFraction(value, curData.minimumFractionDigits, curData.maximumFractionDigits, option);\r\n                if (curData.minimumIntegerDigits) {\r\n                    fValue = this.processMinimumIntegers(fValue, curData.minimumIntegerDigits);\r\n                }\r\n                if (dOptions.isCustomFormat && curData.minimumFractionDigits < curData.maximumFractionDigits\r\n                    && /\\d+\\.\\d+/.test(fValue)) {\r\n                    var temp = fValue.split('.');\r\n                    var decimalPart = temp[1];\r\n                    var len = decimalPart.length;\r\n                    for (var i = len - 1; i >= 0; i--) {\r\n                        if (decimalPart[\"\" + i] === '0' && i >= curData.minimumFractionDigits) {\r\n                            decimalPart = decimalPart.slice(0, i);\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n                    fValue = temp[0] + '.' + decimalPart;\r\n                }\r\n            }\r\n            if (curData.type === 'scientific') {\r\n                fValue = value.toExponential(curData.maximumFractionDigits);\r\n                fValue = fValue.replace('e', dOptions.numberMapper.numberSymbols[mapper[4]]);\r\n            }\r\n            fValue = fValue.replace('.', dOptions.numberMapper.numberSymbols[mapper[3]]);\r\n            fValue = curData.format === \"#,###,,;(#,###,,)\" ? this.customPivotFormat(parseInt(fValue)) : fValue;\r\n            if (curData.useGrouping) {\r\n                /* eslint-disable  @typescript-eslint/no-explicit-any */\r\n                fValue = this.groupNumbers(fValue, curData.groupData.primary, curData.groupSeparator || ',', dOptions.numberMapper.numberSymbols[mapper[3]] || '.', curData.groupData.secondary);\r\n            }\r\n            fValue = parser.convertValueParts(fValue, base.latnParseRegex, dOptions.numberMapper.mapper);\r\n            if (curData.nlead === 'N/A') {\r\n                return curData.nlead;\r\n            }\r\n            else {\r\n                if (fValue === '0' && option && option.format === '0') {\r\n                    return fValue + curData.nend;\r\n                }\r\n                return curData.nlead + fValue + curData.nend;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns significant digits processed numeric string\r\n     *\r\n     * @param {number} value ?\r\n     * @param {number} min ?\r\n     * @param {number} max ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.processSignificantDigits = function (value, min, max) {\r\n        var temp = value + '';\r\n        var tn;\r\n        var length = temp.length;\r\n        if (length < min) {\r\n            return value.toPrecision(min);\r\n        }\r\n        else {\r\n            temp = value.toPrecision(max);\r\n            tn = +temp;\r\n            return tn + '';\r\n        }\r\n    };\r\n    /**\r\n     * Returns grouped numeric string\r\n     *\r\n     * @param {string} val ?\r\n     * @param {number} level1 ?\r\n     * @param {string} sep ?\r\n     * @param {string} decimalSymbol ?\r\n     * @param {number} level2 ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.groupNumbers = function (val, level1, sep, decimalSymbol, level2) {\r\n        var flag = !isNullOrUndefined(level2) && level2 !== 0;\r\n        var split = val.split(decimalSymbol);\r\n        var prefix = split[0];\r\n        var length = prefix.length;\r\n        var str = '';\r\n        while (length > level1) {\r\n            str = prefix.slice(length - level1, length) + (str.length ?\r\n                (sep + str) : '');\r\n            length -= level1;\r\n            if (flag) {\r\n                level1 = level2;\r\n                flag = false;\r\n            }\r\n        }\r\n        split[0] = prefix.slice(0, length) + (str.length ? sep : '') + str;\r\n        return split.join(decimalSymbol);\r\n    };\r\n    /**\r\n     * Returns fraction processed numeric string\r\n     *\r\n     * @param {number} value ?\r\n     * @param {number} min ?\r\n     * @param {number} max ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.processFraction = function (value, min, max, option) {\r\n        var temp = (value + '').split('.')[1];\r\n        var length = temp ? temp.length : 0;\r\n        if (min && length < min) {\r\n            var ret = '';\r\n            if (length === 0) {\r\n                ret = value.toFixed(min);\r\n            }\r\n            else {\r\n                ret += value;\r\n                for (var j = 0; j < min - length; j++) {\r\n                    ret += '0';\r\n                }\r\n                return ret;\r\n            }\r\n            return value.toFixed(min);\r\n        }\r\n        else if (!isNullOrUndefined(max) && (length > max || max === 0)) {\r\n            return value.toFixed(max);\r\n        }\r\n        var str = value + '';\r\n        if (str[0] === '0' && option && option.format === '###.00') {\r\n            str = str.slice(1);\r\n        }\r\n        return str;\r\n    };\r\n    /**\r\n     * Returns integer processed numeric string\r\n     *\r\n     * @param {string} value ?\r\n     * @param {number} min ?\r\n     * @returns {string} ?\r\n     */\r\n    NumberFormat.processMinimumIntegers = function (value, min) {\r\n        var temp = value.split('.');\r\n        var lead = temp[0];\r\n        var len = lead.length;\r\n        if (len < min) {\r\n            for (var i = 0; i < min - len; i++) {\r\n                lead = '0' + lead;\r\n            }\r\n            temp[0] = lead;\r\n        }\r\n        return temp.join('.');\r\n    };\r\n    /**\r\n     * Returns custom format for pivot table\r\n     *\r\n     * @param {number} value ?\r\n     */\r\n    NumberFormat.customPivotFormat = function (value) {\r\n        if (value >= 500000) {\r\n            value /= 1000000;\r\n            var _a = value.toString().split(\".\"), integer = _a[0], decimal = _a[1];\r\n            return decimal && +decimal.substring(0, 1) >= 5\r\n                ? Math.ceil(value).toString()\r\n                : Math.floor(value).toString();\r\n        }\r\n        return \"\";\r\n    };\r\n    return NumberFormat;\r\n}());\r\nexport { NumberFormat };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}