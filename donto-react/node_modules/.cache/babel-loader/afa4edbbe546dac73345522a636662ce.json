{"ast":null,"code":"/* eslint-disable max-len */\nimport { isNullOrUndefined, getDefaultDateObject, getValue, cldrData } from '@syncfusion/ej2-base';\nimport { MS_PER_DAY, addDays, resetTime, capitalizeFirstWord } from '../schedule/base/util';\nimport { Islamic, Gregorian } from '../common/calendar-util';\nimport { Timezone } from '../schedule/timezone/timezone';\n/**\r\n * Date Generator from Recurrence Rule\r\n */\n/**\r\n * Generate Summary from Recurrence Rule\r\n *\r\n * @param {string} rule Accepts the Recurrence rule\r\n * @param {L10n} localeObject Accepts the locale object\r\n * @param {string} locale Accepts the locale name\r\n * @param {CalendarType} calendarType Accepts the calendar type\r\n * @returns {string} Returns the summary string from given recurrence rule\r\n */\nexport function generateSummary(rule, localeObject, locale, calendarType) {\n  if (calendarType === void 0) {\n    calendarType = 'Gregorian';\n  }\n  var ruleObject = extractObjectFromRule(rule);\n  var summary = localeObject.getConstant(EVERY) + ' ';\n  var cldrObj;\n  var cldrObj1;\n  var calendarMode = calendarType.toLowerCase();\n  if (locale === 'en' || locale === 'en-US') {\n    var nameSpace1 = 'months.stand-alone.abbreviated';\n    var nameSpace = 'days.stand-alone.abbreviated';\n    cldrObj1 = getValue(nameSpace1, getDefaultDateObject(calendarMode));\n    cldrObj = getValue(nameSpace, getDefaultDateObject(calendarMode));\n  } else {\n    var nameSpace1 = 'main.' + locale + '.dates.calendars.' + calendarMode + '.months.stand-alone.abbreviated';\n    var nameSpace = 'main.' + locale + '.dates.calendars.' + calendarMode + '.days.stand-alone.abbreviated';\n    cldrObj1 = getValue(nameSpace1, cldrData);\n    cldrObj = getValue(nameSpace, cldrData);\n  }\n  if (ruleObject.interval > 1) {\n    summary += ruleObject.interval + ' ';\n  }\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      summary += localeObject.getConstant(DAYS);\n      break;\n    case 'WEEKLY':\n      summary += localeObject.getConstant(WEEKS) + ' ' + localeObject.getConstant(ON) + ' ';\n      ruleObject.day.forEach(function (day, index) {\n        summary += capitalizeFirstWord(getValue(DAYINDEXOBJECT[\"\" + day], cldrObj), 'single');\n        summary += ruleObject.day.length - 1 === index ? '' : ', ';\n      });\n      break;\n    case 'MONTHLY':\n      summary += localeObject.getConstant(MONTHS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n    case 'YEARLY':\n      summary += localeObject.getConstant(YEARS) + ' ' + localeObject.getConstant(ON) + ' ';\n      summary += capitalizeFirstWord(getValue(ruleObject.month[0].toString(), cldrObj1), 'single') + ' ';\n      summary += getMonthSummary(ruleObject, cldrObj, localeObject);\n      break;\n  }\n  if (ruleObject.count) {\n    summary += ', ' + ruleObject.count + ' ' + localeObject.getConstant(TIMES);\n  } else if (ruleObject.until) {\n    var tempDate = ruleObject.until;\n    summary += ', ' + localeObject.getConstant(UNTIL) + ' ' + tempDate.getDate() + ' ' + capitalizeFirstWord(getValue((tempDate.getMonth() + 1).toString(), cldrObj1), 'single') + ' ' + tempDate.getFullYear();\n  }\n  return summary;\n}\n/**\r\n * Generates Month summary\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {string[]} cldrObj Accepts the collections of month name from calendar\r\n * @param {L10n} localeObj Accepts the locale object\r\n * @returns {string} Returns the month summary string from given recurrence rule object\r\n * @private\r\n */\nfunction getMonthSummary(ruleObject, cldrObj, localeObj) {\n  var summary = '';\n  if (ruleObject.monthDay.length) {\n    summary += ruleObject.monthDay[0];\n  } else if (ruleObject.day) {\n    var pos = ruleObject.setPosition - 1;\n    summary += localeObj.getConstant(WEEKPOS[pos > -1 ? pos : WEEKPOS.length - 1]) + ' ' + capitalizeFirstWord(getValue(DAYINDEXOBJECT[ruleObject.day[0]], cldrObj), 'single');\n  }\n  return summary;\n}\n/**\r\n * Generates the date collections from the given recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the rule start date\r\n * @param {string} rule Accepts the recurrence rule\r\n * @param {string} excludeDate Accepts the exception dates in string format\r\n * @param {number} startDayOfWeek Accepts the start day index of week\r\n * @param {number} maximumCount Accepts the maximum number count to generate date collections\r\n * @param {Date} viewDate Accepts the current date instead of start date\r\n * @param {CalendarType} calendarMode Accepts the calendar type\r\n * @param {string} newTimezone Accepts the timezone name\r\n * @returns {number[]} Returns the collection of dates\r\n */\nexport function generate(startDate, rule, excludeDate, startDayOfWeek, maximumCount, viewDate, calendarMode, newTimezone) {\n  if (maximumCount === void 0) {\n    maximumCount = MAXOCCURRENCE;\n  }\n  if (viewDate === void 0) {\n    viewDate = null;\n  }\n  if (calendarMode === void 0) {\n    calendarMode = 'Gregorian';\n  }\n  if (newTimezone === void 0) {\n    newTimezone = null;\n  }\n  var ruleObject = extractObjectFromRule(rule);\n  var cacheDate;\n  calendarUtil = getCalendarUtil(calendarMode);\n  var data = [];\n  var modifiedDate = new Date(startDate.getTime());\n  tempExcludeDate = [];\n  var tempDate = isNullOrUndefined(excludeDate) ? [] : excludeDate.split(',');\n  var tz = new Timezone();\n  tempDate.forEach(function (content) {\n    var parsedDate = getDateFromRecurrenceDateString(content);\n    if (newTimezone) {\n      parsedDate = tz.add(new Date(parsedDate.getTime()), newTimezone);\n    }\n    tempExcludeDate.push(new Date(parsedDate.getTime()).setHours(0, 0, 0, 0));\n  });\n  ruleObject.recExceptionCount = !isNullOrUndefined(ruleObject.count) ? tempExcludeDate.length : 0;\n  if (viewDate && viewDate > startDate && !ruleObject.count) {\n    tempViewDate = new Date(new Date(viewDate.getTime()).setHours(0, 0, 0));\n  } else {\n    tempViewDate = null;\n  }\n  if (!ruleObject.until && tempViewDate) {\n    cacheDate = new Date(tempViewDate.getTime());\n    cacheDate.setDate(tempViewDate.getDate() + maximumCount * ruleObject.interval);\n    ruleObject.until = cacheDate;\n  }\n  if (ruleObject.until && startDate > ruleObject.until) {\n    return data;\n  }\n  maxOccurrence = maximumCount;\n  setFirstDayOfWeek(DAYINDEX[parseInt(startDayOfWeek.toString(), 10)]);\n  if (ruleObject.until) {\n    var end = resetTime(ruleObject.until);\n    ruleObject.until = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 23, 59, 59);\n  }\n  switch (ruleObject.freq) {\n    case 'DAILY':\n      dailyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n    case 'WEEKLY':\n      weeklyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n    case 'MONTHLY':\n      monthlyType(modifiedDate, ruleObject.until, data, ruleObject);\n      break;\n    case 'YEARLY':\n      yearlyType(modifiedDate, ruleObject.until, data, ruleObject);\n  }\n  return data;\n}\n/**\r\n * Generate date object from given date string\r\n *\r\n * @param {string} recDateString Accepts the exception date as string\r\n * @returns {Date} Returns the date from exception date string\r\n */\nexport function getDateFromRecurrenceDateString(recDateString) {\n  return new Date(recDateString.substr(0, 4) + '-' + recDateString.substr(4, 2) + '-' + recDateString.substr(6, 5) + ':' + recDateString.substr(11, 2) + ':' + recDateString.substr(13));\n}\n/**\r\n * Internal method to handle exclude date\r\n *\r\n * @param {number[]} data Accepts the exception date collections\r\n * @param {number} date Accepts the new exclude date\r\n * @returns {void}\r\n * @private\r\n */\nfunction excludeDateHandler(data, date) {\n  var zeroIndex = new Date(date).setHours(0, 0, 0, 0);\n  if (tempExcludeDate.indexOf(zeroIndex) === -1 && (!tempViewDate || zeroIndex >= tempViewDate.getTime())) {\n    data.push(date);\n  }\n}\n/**\r\n * Internal method for get date count\r\n *\r\n * @param {Date} startDate Accepts the date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {number} Returns the number of date count\r\n * @private\r\n */\nfunction getDateCount(startDate, ruleObject) {\n  var count = maxOccurrence;\n  if (ruleObject.count) {\n    count = ruleObject.count;\n  } else if (ruleObject.until) {\n    if (ruleObject.freq === 'DAILY' || ruleObject.freq === 'WEEKLY') {\n      count = Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1;\n    } else if (ruleObject.freq === 'MONTHLY' || ruleObject.freq === 'YEARLY') {\n      count = Math.floor((ruleObject.until.getMonth() + 12 * ruleObject.until.getFullYear() - (startDate.getMonth() + 12 * startDate.getFullYear())) / ruleObject.interval) + (ruleObject.day.length > 1 ? Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1 : 1);\n      if (ruleObject.freq === 'YEARLY') {\n        count = ruleObject.month.length > 1 ? count * ruleObject.month.length : count;\n      }\n    }\n  }\n  return count;\n}\n/**\r\n *  Internal method for daily type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction dailyType(startDate, endDate, data, ruleObject) {\n  var tempDate = new Date(startDate.getTime());\n  var interval = ruleObject.interval;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var state;\n  var expectedDays = ruleObject.day;\n  while (compareDates(tempDate, endDate)) {\n    state = true;\n    state = validateRules(tempDate, ruleObject);\n    if (state && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1 || expectedDays.length === 0)) {\n      excludeDateHandler(data, tempDate.getTime());\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n    }\n    tempDate.setDate(tempDate.getDate() + interval);\n    if (tempDate.getHours() !== startDate.getHours()) {\n      tempDate.setHours(startDate.getHours());\n    }\n  }\n}\n/**\r\n * Internal method for weekly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction weeklyType(startDate, endDate, data, ruleObject) {\n  var tempDate = new Date(startDate.getTime());\n  if (!ruleObject.day.length) {\n    ruleObject.day.push(DAYINDEX[startDate.getDay()]);\n  }\n  var interval = ruleObject.interval;\n  var expectedDays = ruleObject.day;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var weekState = true;\n  var wkstIndex;\n  var weekCollection = [];\n  if (expectedDays.length > 1) {\n    if (isNullOrUndefined(ruleObject.wkst) || ruleObject.wkst === '') {\n      ruleObject.wkst = dayIndex[0];\n    }\n    wkstIndex = DAYINDEX.indexOf(ruleObject.wkst);\n    while (compareDates(tempDate, endDate)) {\n      var startDateDiff = DAYINDEX.indexOf(DAYINDEX[tempDate.getDay()]) - wkstIndex;\n      startDateDiff = startDateDiff === -1 ? 6 : startDateDiff;\n      var weekstartDate = addDays(tempDate, -startDateDiff);\n      var weekendDate = addDays(weekstartDate, 6);\n      var compareTempDate = new Date(tempDate.getTime());\n      weekendDate = resetTime(weekendDate);\n      compareTempDate = resetTime(compareTempDate);\n      while (weekendDate >= compareTempDate) {\n        if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          weekCollection.push([tempDate.getTime()]);\n        }\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          break;\n        }\n        tempDate.setDate(tempDate.getDate() + 1);\n        if (tempDate.getHours() !== startDate.getHours()) {\n          tempDate.setHours(startDate.getHours());\n        }\n        compareTempDate = new Date(tempDate.getTime());\n        compareTempDate = resetTime(compareTempDate);\n      }\n      tempDate.setDate(tempDate.getDate() - 1);\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n      tempDate.setDate(tempDate.getDate() + 1 + (interval - 1) * 7);\n      insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\n      weekCollection = [];\n    }\n  } else {\n    tempDate = getStartDateForWeek(startDate, ruleObject.day);\n    while (compareDates(tempDate, endDate)) {\n      weekState = validateRules(tempDate, ruleObject);\n      if (weekState && expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n        excludeDateHandler(data, tempDate.getTime());\n      }\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        break;\n      }\n      tempDate.setDate(tempDate.getDate() + interval * 7);\n    }\n    insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\n    weekCollection = [];\n  }\n}\n/**\r\n *  Internal method for monthly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction monthlyType(startDate, endDate, data, ruleObject) {\n  // Set monthday value if BYDAY, BYMONTH and Month day property is not set based on start date\n  if (!ruleObject.month.length && !ruleObject.day.length && !ruleObject.monthDay.length) {\n    ruleObject.monthDay.push(startDate.getDate());\n    if (ruleObject.freq === 'YEARLY') {\n      ruleObject.month.push(startDate.getMonth() + 1);\n    }\n  } else if (ruleObject.month.length > 0 && !ruleObject.day.length && !ruleObject.monthDay.length) {\n    ruleObject.monthDay.push(startDate.getDate());\n  }\n  var ruleType = validateMonthlyRuleType(ruleObject);\n  switch (ruleType) {\n    case 'day':\n      switch (ruleObject.freq) {\n        case 'MONTHLY':\n          monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n          break;\n        case 'YEARLY':\n          monthlyDayTypeProcess(startDate, endDate, data, ruleObject);\n          break;\n      }\n      break;\n    case 'both':\n    case 'date':\n      switch (ruleObject.freq) {\n        case 'MONTHLY':\n          monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n          break;\n        case 'YEARLY':\n          monthlyDateTypeProcess(startDate, endDate, data, ruleObject);\n          break;\n      }\n      break;\n  }\n}\n/**\r\n * Internal method for yearly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction yearlyType(startDate, endDate, data, ruleObject) {\n  var typeValue = checkYearlyType(ruleObject);\n  switch (typeValue) {\n    case 'MONTH':\n      monthlyType(startDate, endDate, data, ruleObject);\n      break;\n    case 'WEEKNO':\n      processWeekNo(startDate, endDate, data, ruleObject);\n      break;\n    case 'YEARDAY':\n      processYearDay(startDate, endDate, data, ruleObject);\n      break;\n  }\n}\n/**\r\n * Internal method for process week no\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction processWeekNo(startDate, endDate, data, ruleObject) {\n  var stDate = calendarUtil.getYearLastDate(startDate, 0);\n  var tempDate;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var state;\n  var startDay;\n  var firstWeekSpan;\n  var weekNos = ruleObject.weekNo;\n  var weekNo;\n  var maxDate;\n  var minDate;\n  var weekCollection = [];\n  var expectedDays = ruleObject.day;\n  while (compareDates(stDate, endDate)) {\n    startDay = dayIndex.indexOf(DAYINDEX[stDate.getDay()]);\n    firstWeekSpan = 6 - startDay + 1;\n    for (var index = 0; index < weekNos.length; index++) {\n      weekNo = weekNos[parseInt(index.toString(), 10)];\n      weekNo = weekNo > 0 ? weekNo : 53 + weekNo + 1;\n      maxDate = weekNo === 1 ? firstWeekSpan : firstWeekSpan + (weekNo - 1) * 7;\n      minDate = weekNo === 1 ? firstWeekSpan - 7 : firstWeekSpan + (weekNo - 2) * 7;\n      while (minDate < maxDate) {\n        tempDate = new Date(stDate.getTime() + MS_PER_DAY * minDate);\n        if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\n          } else {\n            weekCollection.push([tempDate.getTime()]);\n          }\n        }\n        minDate++;\n      }\n    }\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(weekCollection, state, startDate, endDate, data, ruleObject);\n    }\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n    stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\n    weekCollection = [];\n  }\n}\n/**\r\n * Internal method for process year day\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction processYearDay(startDate, endDate, data, ruleObject) {\n  var stDate = calendarUtil.getYearLastDate(startDate, 0);\n  var tempDate;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var state;\n  var dateCollection = [];\n  var date;\n  var expectedDays = ruleObject.day;\n  while (compareDates(stDate, endDate)) {\n    for (var index = 0; index < ruleObject.yearDay.length; index++) {\n      date = ruleObject.yearDay[parseInt(index.toString(), 10)];\n      tempDate = new Date(stDate.getTime());\n      if ((date === calendarUtil.getLeapYearDaysCount() || date === -calendarUtil.getLeapYearDaysCount()) && !calendarUtil.isLeapYear(calendarUtil.getFullYear(tempDate), 1)) {\n        tempDate.setDate(tempDate.getDate() + 1);\n        continue;\n      }\n      tempDate.setDate(tempDate.getDate() + (date < 0 ? calendarUtil.getYearDaysCount(tempDate, 1) + 1 + date : date));\n      if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n        if (ruleObject.setPosition == null) {\n          insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\n        } else {\n          dateCollection.push([tempDate.getTime()]);\n        }\n      }\n    }\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject);\n    }\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n    stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\n    dateCollection = [];\n  }\n}\n/**\r\n * Internal method to check yearly type\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {YearRuleType} Returns the Yearly rule type object\r\n * @private\r\n */\nfunction checkYearlyType(ruleObject) {\n  if (ruleObject.yearDay.length) {\n    return 'YEARDAY';\n  } else if (ruleObject.weekNo.length) {\n    return 'WEEKNO';\n  }\n  return 'MONTH';\n}\n/**\r\n * Internal method to initialize recurrence rule variables\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {RuleData} Return the rule data object\r\n * @private\r\n */\nfunction initializeRecRuleVariables(startDate, ruleObject) {\n  var ruleData = {\n    monthCollection: [],\n    index: 0,\n    tempDate: new Date(startDate.getTime()),\n    mainDate: new Date(startDate.getTime()),\n    expectedCount: getDateCount(startDate, ruleObject),\n    monthInit: 0,\n    dateCollection: []\n  };\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(ruleData.tempDate, ruleObject.month[0], ruleData.tempDate.getDate());\n  }\n  return ruleData;\n}\n/**\r\n * Internal method for process monthly date type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction monthlyDateTypeProcess(startDate, endDate, data, ruleObject) {\n  if (ruleObject.month.length) {\n    monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n    return;\n  }\n  var ruleData = initializeRecRuleVariables(startDate, ruleObject);\n  var currentMonthDate;\n  ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\n  while (compareDates(ruleData.tempDate, endDate)) {\n    currentMonthDate = new Date(ruleData.tempDate.getTime());\n    while (calendarUtil.isSameYear(currentMonthDate, ruleData.tempDate) && ruleData.expectedCount && data.length + ruleObject.recExceptionCount <= ruleData.expectedCount) {\n      if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && !calendarUtil.checkMonth(ruleData.tempDate, ruleObject.month)) {\n        processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, false);\n        ruleData.beginDate = new Date(ruleData.tempDate.getTime());\n        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n      } else {\n        calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\n        ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n        break;\n      }\n    }\n    ruleData.tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\n    insertDataCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\n    if (calendarUtil.isLastMonth(ruleData.tempDate)) {\n      calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\n      ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n    }\n    if (ruleData.expectedCount && data.length + ruleObject.recExceptionCount >= ruleData.expectedCount) {\n      return;\n    }\n    ruleData.tempDate.setFullYear(ruleData.tempDate.getFullYear() + ruleObject.interval - 1);\n    ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\n    ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n    ruleData.dateCollection = [];\n  }\n}\n/**\r\n * Internal method for process monthly date type with month frequency from recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\n  var ruleData = initializeRecRuleVariables(startDate, ruleObject);\n  ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\n  if ((ruleObject.freq === 'MONTHLY' && ruleObject.interval === 12 || ruleObject.freq === 'YEARLY') && calendarUtil.getMonthDaysCount(startDate) < ruleObject.monthDay[0]) {\n    return;\n  }\n  while (compareDates(ruleData.tempDate, endDate)) {\n    ruleData.beginDate = new Date(ruleData.tempDate.getTime());\n    processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, true, startDate, data);\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDatasIntoExistingCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\n    }\n    if (ruleData.expectedCount && data.length + ruleObject.recExceptionCount >= ruleData.expectedCount) {\n      return;\n    }\n    ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\n    ruleData.dateCollection = [];\n  }\n}\n/**\r\n * To process date collection for Monthly & Yearly based on BYMONTH Day property\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {RuleData} recRuleVariables Accepts the rule data\r\n * @param {Date} endDate Accepts the end date\r\n * @param {boolean} isByMonth Accepts the boolean to validate either month or not\r\n * @param {Date} startDate Accepts the start date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @returns {void}\r\n * @private\r\n */\nfunction processDateCollectionForByMonthDay(ruleObject, recRuleVariables, endDate, isByMonth, startDate, data) {\n  for (var index = 0; index < ruleObject.monthDay.length; index++) {\n    recRuleVariables.date = ruleObject.monthDay[parseInt(index.toString(), 10)];\n    recRuleVariables.tempDate = calendarUtil.getMonthStartDate(recRuleVariables.tempDate);\n    var maxDate = calendarUtil.getMonthDaysCount(recRuleVariables.tempDate);\n    recRuleVariables.date = recRuleVariables.date > 0 ? recRuleVariables.date : maxDate + recRuleVariables.date + 1;\n    if (validateProperDate(recRuleVariables.tempDate, recRuleVariables.date, recRuleVariables.mainDate) && recRuleVariables.date > 0) {\n      calendarUtil.setDate(recRuleVariables.tempDate, recRuleVariables.date);\n      if (endDate && recRuleVariables.tempDate > endDate) {\n        return;\n      }\n      if (ruleObject.day.length === 0 || ruleObject.day.indexOf(DAYINDEX[recRuleVariables.tempDate.getDay()]) > -1) {\n        if (isByMonth && isNullOrUndefined(ruleObject.setPosition) && recRuleVariables.expectedCount && data.length + ruleObject.recExceptionCount < recRuleVariables.expectedCount) {\n          insertDateCollection(recRuleVariables.state, startDate, endDate, data, ruleObject, recRuleVariables.tempDate.getTime());\n        } else {\n          recRuleVariables.dateCollection.push([recRuleVariables.tempDate.getTime()]);\n        }\n      }\n    }\n  }\n}\n/**\r\n * Internal method to set next valid date\r\n *\r\n * @param {Date} tempDate Accepts the date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} monthInit Accepts the initial month\r\n * @param {Date} beginDate Accepts the initial date\r\n * @param {number} interval Accepts the interval duration\r\n * @returns {number} Returnx the next valid date\r\n * @private\r\n */\nfunction setNextValidDate(tempDate, ruleObject, monthInit, beginDate, interval) {\n  if (beginDate === void 0) {\n    beginDate = null;\n  }\n  var monthData = beginDate ? beginDate.getMonth() : 0;\n  var startDate = calendarUtil.getMonthStartDate(tempDate);\n  interval = isNullOrUndefined(interval) ? ruleObject.interval : interval;\n  tempDate.setFullYear(startDate.getFullYear());\n  tempDate.setMonth(startDate.getMonth());\n  tempDate.setDate(startDate.getDate());\n  if (ruleObject.month.length) {\n    monthInit++;\n    monthInit = monthInit % ruleObject.month.length;\n    calendarUtil.setMonth(tempDate, ruleObject.month[parseInt(monthInit.toString(), 10)], 1);\n    if (monthInit === 0) {\n      calendarUtil.addYears(tempDate, interval, ruleObject.month[0]);\n    }\n  } else {\n    if (beginDate && beginDate.getFullYear() < tempDate.getFullYear()) {\n      monthData = tempDate.getMonth() - 1;\n    }\n    calendarUtil.setValidDate(tempDate, interval, 1, monthData, beginDate);\n  }\n  return monthInit;\n}\n/**\r\n * To get month collection when BYDAY property having more than one value in list.\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction getMonthCollection(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var tempDate = new Date(startDate.getTime());\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  var monthCollection = [];\n  var dateCollection = [];\n  var dates = [];\n  var index;\n  var state;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var monthInit = 0;\n  var beginDate;\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n  while (compareDates(tempDate, endDate) && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    var currentMonthDate = new Date(tempDate.getTime());\n    var isHavingNumber = expectedDays.map(function (item) {\n      return HASNUMBER.test(item);\n    });\n    if (isHavingNumber.indexOf(true) > -1) {\n      for (var j = 0; j <= expectedDays.length - 1; j++) {\n        var expectedDaysArray = expectedDays[parseInt(j.toString(), 10)].match(SPLITNUMBERANDSTRING);\n        var position = parseInt(expectedDaysArray[0], 10);\n        tempDate = new Date(tempDate.getTime());\n        tempDate = calendarUtil.getMonthStartDate(tempDate);\n        tempDate = getStartDateForWeek(tempDate, expectedDays);\n        currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) && calendarUtil.isSameMonth(currentMonthDate, tempDate)) {\n          if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentMonthDate.getDay()]) {\n            monthCollection.push([currentMonthDate.getTime()]);\n          }\n          currentMonthDate.setDate(currentMonthDate.getDate() + 1);\n        }\n        currentMonthDate.setDate(currentMonthDate.getDate() - 1);\n        if (expectedDaysArray[0].indexOf('-') > -1) {\n          index = monthCollection.length - -1 * position;\n        } else {\n          index = position - 1;\n        }\n        index = isNaN(index) ? 0 : index;\n        if (monthCollection.length > 0) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n          } else {\n            dateCollection = [filterDateCollectionByIndex(monthCollection, index, dates)];\n          }\n        }\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          return;\n        }\n        monthCollection = [];\n      }\n      if (!isNullOrUndefined(ruleObject.setPosition)) {\n        insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n        dates = [];\n      }\n      monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n      monthCollection = [];\n    } else {\n      var weekCollection = [];\n      var dayCycleData = processWeekDays(expectedDays);\n      currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\n      var initialDate = new Date(tempDate.getTime());\n      beginDate = new Date(tempDate.getTime());\n      while (calendarUtil.isSameMonth(initialDate, tempDate)) {\n        weekCollection.push(tempDate.getTime());\n        if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\n          monthCollection.push(weekCollection);\n          weekCollection = [];\n        }\n        tempDate.setDate(tempDate.getDate() + dayCycleData[DAYINDEX[tempDate.getDay()]]);\n      }\n      index = ruleObject.setPosition < 1 ? monthCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n      if (isNullOrUndefined(ruleObject.setPosition)) {\n        index = 0;\n        var datas = [];\n        for (var week = 0; week < monthCollection.length; week++) {\n          for (var row = 0; row < monthCollection[parseInt(week.toString(), 10)].length; row++) {\n            datas.push(monthCollection[parseInt(week.toString(), 10)][parseInt(row.toString(), 10)]);\n          }\n        }\n        monthCollection = [datas];\n      }\n      if (monthCollection.length > 0) {\n        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n      }\n      if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n        return;\n      }\n      monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n      monthCollection = [];\n    }\n  }\n}\n/**\r\n * To process monday day type for FREQ=MONTHLY\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  // When BYDAY property having more than 1 value.\n  if (expectedDays.length > 1) {\n    getMonthCollection(startDate, endDate, data, ruleObject);\n    return;\n  }\n  var tempDate = new Date(startDate.getTime());\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var monthCollection = [];\n  var beginDate;\n  var monthInit = 0;\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n  while (compareDates(tempDate, endDate) && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    beginDate = new Date(tempDate.getTime());\n    var currentMonthDate = new Date(tempDate.getTime());\n    while (calendarUtil.isSameMonth(tempDate, currentMonthDate)) {\n      monthCollection.push([currentMonthDate.getTime()]);\n      currentMonthDate.setDate(currentMonthDate.getDate() + 7);\n    }\n    // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n    insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\n    monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    monthCollection = [];\n  }\n}\n/**\r\n * To process monday day type for FREQ=YEARLY\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction monthlyDayTypeProcess(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var isHavingNumber = expectedDays.map(function (item) {\n    return HASNUMBER.test(item);\n  });\n  // If BYDAY property having more than 1 value in list\n  if (expectedDays.length > 1 && isHavingNumber.indexOf(true) > -1) {\n    processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject);\n    return;\n  } else if (ruleObject.month.length && expectedDays.length === 1 && isHavingNumber.indexOf(true) > -1) {\n    monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\n    return;\n  }\n  var tempDate = new Date(startDate.getTime());\n  var currentMonthDate;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var interval = ruleObject.interval;\n  var monthCollection = [];\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\n  }\n  // Set the date as start date of the yeear if yearly freq having ByDay property alone\n  if (isNullOrUndefined(ruleObject.setPosition) && ruleObject.month.length === 0 && ruleObject.weekNo.length === 0) {\n    tempDate.setFullYear(startDate.getFullYear(), 0, 1);\n  }\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n  while (compareDates(tempDate, endDate)) {\n    currentMonthDate = new Date(tempDate.getTime());\n    while (calendarUtil.isSameYear(currentMonthDate, tempDate) && expectedCount && data.length + ruleObject.recExceptionCount <= expectedCount) {\n      currentMonthDate = new Date(tempDate.getTime());\n      while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\n        if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && !calendarUtil.checkMonth(tempDate, ruleObject.month)) {\n          if (expectedDays.length > 1) {\n            if (calendarUtil.compareMonth(currentMonthDate, tempDate)) {\n              calendarUtil.setValidDate(tempDate, 1, 1);\n              tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n              break;\n            }\n            if (expectedDays.indexOf(DAYINDEX[currentMonthDate.getDay()]) > -1) {\n              monthCollection.push([currentMonthDate.getTime()]);\n            }\n            currentMonthDate.setDate(currentMonthDate.getDate() + 1);\n          } else {\n            // If BYDAY property having 1 value in list\n            if (currentMonthDate.getFullYear() > tempDate.getFullYear()) {\n              calendarUtil.setValidDate(tempDate, 1, 1);\n              tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n              break;\n            }\n            var newstr = getDayString(expectedDays[0]);\n            if (DAYINDEX[currentMonthDate.getDay()] === newstr && new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), 0) > new Date(startDate.getFullYear())) {\n              monthCollection.push([currentMonthDate.getTime()]);\n            }\n            currentMonthDate.setDate(currentMonthDate.getDate() + 7);\n          }\n        } else {\n          calendarUtil.setValidDate(tempDate, 1, 1);\n          tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n          break;\n        }\n      }\n    }\n    tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\n    // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\n    insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\n    if (calendarUtil.isLastMonth(tempDate)) {\n      calendarUtil.setValidDate(tempDate, 1, 1);\n      tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    }\n    tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\n    if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n      return;\n    }\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    monthCollection = [];\n  }\n}\n/**\r\n * To process the recurrence rule when BYDAY property having values with integer\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var tempDate = new Date(startDate.getTime());\n  var interval = ruleObject.interval;\n  var monthCollection = [];\n  var dateCollection = [];\n  var index;\n  var state;\n  var monthInit = 0;\n  var currentMonthDate;\n  var currentDate;\n  var beginDate;\n  tempDate = calendarUtil.getMonthStartDate(tempDate);\n  var datas = [];\n  if (ruleObject.month.length) {\n    calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\n  }\n  tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n  while (compareDates(tempDate, endDate)) {\n    currentMonthDate = new Date(tempDate.getTime());\n    for (var i = 0; i <= ruleObject.month.length; i++) {\n      for (var j = 0; j <= expectedDays.length - 1; j++) {\n        tempDate = calendarUtil.getMonthStartDate(tempDate);\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n        monthCollection = [];\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) && expectedCount && data.length + ruleObject.recExceptionCount <= expectedCount) {\n          while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\n            currentMonthDate = new Date(tempDate.getTime());\n            if (ruleObject.month.length === 0 || ruleObject.month.length > 0 && ruleObject.month[parseInt(i.toString(), 10)] === calendarUtil.getMonth(currentMonthDate)) {\n              var expectedDaysArray = expectedDays[parseInt(j.toString(), 10)].match(SPLITNUMBERANDSTRING);\n              var position = parseInt(expectedDaysArray[0], 10);\n              currentDate = new Date(tempDate.getTime());\n              while (calendarUtil.isSameYear(currentDate, tempDate) && calendarUtil.isSameMonth(currentDate, tempDate)) {\n                if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentDate.getDay()]) {\n                  monthCollection.push([currentDate.getTime()]);\n                }\n                currentDate.setDate(currentDate.getDate() + 1);\n              }\n              currentDate.setDate(currentDate.getDate() - 1);\n              if (expectedDaysArray[0].indexOf('-') > -1) {\n                index = monthCollection.length - -1 * position;\n              } else {\n                index = position - 1;\n              }\n              index = isNaN(index) ? 0 : index;\n            }\n            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate, 1);\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n          }\n        }\n        tempDate = j === 0 && currentDate ? new Date(currentDate.getTime()) : new Date(currentMonthDate.getTime());\n        if (monthCollection.length > 0) {\n          if (isNullOrUndefined(ruleObject.setPosition)) {\n            insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n          } else {\n            dateCollection = [filterDateCollectionByIndex(monthCollection, index, datas)];\n          }\n        }\n        if (expectedCount && data.length + ruleObject.recExceptionCount >= expectedCount) {\n          return;\n        }\n      }\n    }\n    if (!isNullOrUndefined(ruleObject.setPosition)) {\n      insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n      datas = [];\n    }\n    if (calendarUtil.isLastMonth(tempDate)) {\n      calendarUtil.setValidDate(tempDate, 1, 1);\n      tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\n    } else {\n      tempDate.setFullYear(tempDate.getFullYear() + interval);\n    }\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\n    if (ruleObject.month.length) {\n      calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\n    }\n  }\n}\n/**\r\n * To get recurrence collection if BYSETPOS is null\r\n *\r\n * @param {number[]} monthCollection Accepts the month collection dates\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {RuleData} Returns the rule data object\r\n * @private\r\n */\nfunction getRecurrenceCollection(monthCollection, expectedDays) {\n  var index;\n  var recurrenceCollectionObject = {\n    monthCollection: [],\n    index: 0\n  };\n  if (expectedDays.length === 1) {\n    // To split numeric value from BYDAY property value\n    var expectedDaysArrays = expectedDays[0].match(SPLITNUMBERANDSTRING);\n    var arrPosition = void 0;\n    if (expectedDaysArrays.length > 1) {\n      arrPosition = parseInt(expectedDaysArrays[0], 10);\n      index = arrPosition < 1 ? monthCollection.length + arrPosition : arrPosition - 1;\n    } else {\n      index = 0;\n      monthCollection = getDateCollectionforBySetPosNull(monthCollection);\n    }\n  } else {\n    index = 0;\n    monthCollection = getDateCollectionforBySetPosNull(monthCollection);\n  }\n  recurrenceCollectionObject.monthCollection = monthCollection;\n  recurrenceCollectionObject.index = index;\n  return recurrenceCollectionObject;\n}\n/**\r\n * Internal method to process the data collections\r\n *\r\n * @param {number[]} dateCollection Accepts the date collections\r\n * @param {boolean} state Accepts the state\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of numbers\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction insertDataCollection(dateCollection, state, startDate, endDate, data, ruleObject) {\n  var index = ruleObject.setPosition < 1 ? dateCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n  if (isNullOrUndefined(ruleObject.setPosition)) {\n    index = 0;\n    dateCollection = getDateCollectionforBySetPosNull(dateCollection);\n  }\n  if (dateCollection.length > 0) {\n    insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject, index);\n  }\n}\n/**\r\n * To process month collection if BYSETPOS is null\r\n *\r\n * @param {number[]} monthCollection Accepts the month date collections\r\n * @returns {number[]} Returns the month date collections\r\n * @private\r\n */\nfunction getDateCollectionforBySetPosNull(monthCollection) {\n  var datas = [];\n  for (var week = 0; week < monthCollection.length; week++) {\n    for (var row = 0; row < monthCollection[parseInt(week.toString(), 10)].length; row++) {\n      datas.push(new Date(monthCollection[parseInt(week.toString(), 10)][parseInt(row.toString(), 10)]).getTime());\n    }\n  }\n  monthCollection = datas.length > 0 ? [datas] : [];\n  return monthCollection;\n}\n/**\r\n * To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\r\n *\r\n * @param {number[]} monthCollection Accepts the month date collections\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the date collections\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject) {\n  var expectedDays = ruleObject.day;\n  var state;\n  var datas = [];\n  var dateCollection = [];\n  var recurrenceCollections = getRecurrenceCollection(monthCollection, expectedDays);\n  monthCollection = recurrenceCollections.monthCollection;\n  var index = recurrenceCollections.index;\n  if (ruleObject.setPosition != null) {\n    dateCollection = [filterDateCollectionByIndex(monthCollection, index, datas)];\n    insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\n  } else {\n    if (monthCollection.length > 0) {\n      insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\n    }\n  }\n  datas = [];\n}\n/**\r\n * To filter date collection when BYDAY property having values with number\r\n *\r\n * @param {number[]} monthCollection Accepts the date collections\r\n * @param {number} index Accepts the index of date collections\r\n * @param {number[]} datas Accepts the collection of dates\r\n * @returns {number[]} Returns the collection of dates\r\n * @private\r\n */\nfunction filterDateCollectionByIndex(monthCollection, index, datas) {\n  for (var week = 0; week < monthCollection[parseInt(index.toString(), 10)].length; week++) {\n    datas.push(monthCollection[parseInt(index.toString(), 10)][parseInt(week.toString(), 10)]);\n  }\n  return datas;\n}\n/**\r\n * To insert processed date collection in final array element\r\n *\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} dayData Accepts the date index\r\n * @returns {void}\r\n * @private\r\n */\nfunction insertDateCollection(state, startDate, endDate, data, ruleObject, dayData) {\n  var expectedCount = getDateCount(startDate, ruleObject);\n  var chDate = new Date(dayData);\n  state = validateRules(chDate, ruleObject);\n  if (chDate >= startDate && compareDates(chDate, endDate) && state && expectedCount && data.length + ruleObject.recExceptionCount < expectedCount) {\n    excludeDateHandler(data, dayData);\n  }\n}\n/**\r\n * Return the last week number of given month and year.\r\n *\r\n * @param {number} year Accepts the Year in number format\r\n * @param {number} startDayOfWeek Accepts the start date\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {number} week Accepts the week in number format\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {number} returns week number\r\n * @private\r\n */\nfunction weekCount(year, startDayOfWeek, monthCollection, week, ruleObject) {\n  var firstDayOfWeek = startDayOfWeek || 0;\n  var firstOfMonth = new Date(year, ruleObject.month[0] - 1, 1);\n  var lastOfMonth = new Date(year, ruleObject.month[0], 0);\n  var numberOfDaysInMonth = lastOfMonth.getDate();\n  var firstWeekDay = (firstOfMonth.getDay() - firstDayOfWeek + 7) % 7;\n  var used = firstWeekDay + numberOfDaysInMonth;\n  var count = Math.ceil(used / 7) - 1;\n  var dayData = monthCollection[parseInt(week.toString(), 10)][parseInt(count.toString(), 10)];\n  var chDate = new Date(dayData);\n  var state = validateRules(chDate, ruleObject);\n  return state ? count : count - 1;\n}\n/**\r\n * To process date collection based on Byset position after process the collection based on BYDAY property value index: EX:BYDAY=1SUm-1SU\r\n *\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\nfunction insertDateCollectionBasedonBySetPos(monthCollection, state, startDate, endDate, data, ruleObject) {\n  if (monthCollection.length > 0) {\n    for (var week = 0; week < monthCollection.length; week++) {\n      monthCollection[parseInt(week.toString(), 10)].sort();\n      var expectedDays = ruleObject.day;\n      var isHavingNumber = expectedDays.map(function (item) {\n        return HASNUMBER.test(item);\n      });\n      var weekIndex = ruleObject.freq === 'YEARLY' && ruleObject.validRules.indexOf('BYMONTH') > -1 && !(isHavingNumber.indexOf(true) > -1) ? weekCount(new Date(monthCollection[0][0]).getFullYear(), 0, monthCollection, week, ruleObject) : monthCollection[parseInt(week.toString(), 10)].length + ruleObject.setPosition;\n      var index = ruleObject.setPosition < 1 ? weekIndex : ruleObject.setPosition - 1;\n      var dayData = monthCollection[parseInt(week.toString(), 10)][parseInt(index.toString(), 10)];\n      insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\n    }\n  }\n}\n/**\r\n * To insert datas into existing collection which is processed from previous loop.\r\n *\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} index Accepts the index value\r\n * @returns {void}\r\n * @private\r\n */\nfunction insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index) {\n  if (monthCollection.length > 0) {\n    index = !isNullOrUndefined(index) ? index : ruleObject.setPosition < 1 ? monthCollection.length + ruleObject.setPosition : ruleObject.setPosition - 1;\n    monthCollection[parseInt(index.toString(), 10)].sort();\n    for (var week = 0; week < monthCollection[parseInt(index.toString(), 10)].length; week++) {\n      var dayData = monthCollection[parseInt(index.toString(), 10)][parseInt(week.toString(), 10)];\n      insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\n    }\n  }\n}\n/**\r\n * Internal method to compare dates\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @returns {boolean} Returns the result of checking start and end dates\r\n * @private\r\n */\nfunction compareDates(startDate, endDate) {\n  return endDate ? startDate <= endDate : true;\n}\n/**\r\n * Internal method to get day string\r\n *\r\n * @param {string} expectedDays Accepts the exception date string\r\n * @returns {string} Returns the valid string\r\n * @private\r\n */\nfunction getDayString(expectedDays) {\n  // To get BYDAY value without numeric value\n  var newstr = expectedDays.replace(REMOVENUMBERINSTRING, '');\n  return newstr;\n}\n/**\r\n * Internal method to check day index\r\n *\r\n * @param {number} day Accepts the day index\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {boolean} Returns the index date\r\n * @private\r\n */\nfunction checkDayIndex(day, expectedDays) {\n  var sortedExpectedDays = [];\n  expectedDays.forEach(function (element) {\n    var expectedDaysNumberSplit = element.match(SPLITNUMBERANDSTRING);\n    if (expectedDaysNumberSplit.length === 2) {\n      sortedExpectedDays.push(expectedDaysNumberSplit[1]);\n    } else {\n      sortedExpectedDays.push(expectedDaysNumberSplit[0]);\n    }\n  });\n  return sortedExpectedDays.indexOf(DAYINDEX[parseInt(day.toString(), 10)]) === -1;\n}\n/**\r\n * Internal method to get start date of week\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {Date} Return the week start date\r\n * @private\r\n */\nfunction getStartDateForWeek(startDate, expectedDays) {\n  var tempDate = new Date(startDate.getTime());\n  var newstr;\n  if (expectedDays.length > 0) {\n    var expectedDaysArr = [];\n    for (var i = 0; i <= expectedDays.length - 1; i++) {\n      newstr = getDayString(expectedDays[parseInt(i.toString(), 10)]);\n      expectedDaysArr.push(newstr);\n    }\n    if (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1) {\n      do {\n        tempDate.setDate(tempDate.getDate() + 1);\n      } while (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1);\n    }\n  }\n  return tempDate;\n}\n/**\r\n * Method to generate recurrence rule object from given rule\r\n *\r\n * @param {string} rules Accepts the recurrence rule\r\n * @returns {RecRule} Returns the recurrence rule object\r\n */\nexport function extractObjectFromRule(rules) {\n  var ruleObject = {\n    freq: null,\n    interval: 1,\n    count: null,\n    until: null,\n    day: [],\n    wkst: null,\n    month: [],\n    weekNo: [],\n    monthDay: [],\n    yearDay: [],\n    setPosition: null,\n    validRules: []\n  };\n  var rulesList = rules.split(';');\n  var splitData = [];\n  var temp;\n  rulesList.forEach(function (data) {\n    splitData = data.split('=');\n    switch (splitData[0]) {\n      case 'UNTIL':\n        temp = splitData[1];\n        ruleObject.until = getDateFromRecurrenceDateString(temp);\n        break;\n      case 'BYDAY':\n        ruleObject.day = splitData[1].split(',');\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'BYMONTHDAY':\n        ruleObject.monthDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'BYMONTH':\n        ruleObject.month = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'BYYEARDAY':\n        ruleObject.yearDay = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'BYWEEKNO':\n        ruleObject.weekNo = splitData[1].split(',').map(Number);\n        ruleObject.validRules.push(splitData[0]);\n        break;\n      case 'INTERVAL':\n        ruleObject.interval = parseInt(splitData[1], 10);\n        break;\n      case 'COUNT':\n        ruleObject.count = parseInt(splitData[1], 10);\n        break;\n      case 'BYSETPOS':\n        ruleObject.setPosition = parseInt(splitData[1], 10) > 4 ? -1 : parseInt(splitData[1], 10);\n        break;\n      case 'FREQ':\n        ruleObject.freq = splitData[1];\n        break;\n      case 'WKST':\n        ruleObject.wkst = splitData[1];\n        break;\n    }\n  });\n  if (ruleObject.freq === 'MONTHLY' && ruleObject.monthDay.length === 0) {\n    var index = ruleObject.validRules.indexOf('BYDAY');\n    ruleObject.validRules.splice(index, 1);\n  }\n  return ruleObject;\n}\n/**\r\n * Internal method to validate proper date\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number} data Accepts the data value\r\n * @param {Date} startDate Accepts the start date\r\n * @returns {boolean} Returns the result of date validate\r\n * @private\r\n */\nfunction validateProperDate(tempDate, data, startDate) {\n  var maxDate = calendarUtil.getMonthDaysCount(tempDate);\n  return data <= maxDate && tempDate >= startDate;\n}\n/**\r\n * Internal method to process week days\r\n *\r\n * @param {string[]} expectedDays Accepts the expection dates\r\n * @returns {Object} Returns the weekdays object\r\n * @private\r\n */\nfunction processWeekDays(expectedDays) {\n  var dayCycle = {};\n  expectedDays.forEach(function (element, index) {\n    if (index === expectedDays.length - 1) {\n      var startIndex = dayIndex.indexOf(element);\n      var temp = startIndex;\n      while (temp % 7 !== dayIndex.indexOf(expectedDays[0])) {\n        temp++;\n      }\n      dayCycle[\"\" + element] = temp - startIndex;\n    } else {\n      dayCycle[\"\" + element] = dayIndex.indexOf(expectedDays[index + 1]) - dayIndex.indexOf(element);\n    }\n  });\n  return dayCycle;\n}\n/**\r\n * Internal method to check date\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number[]} expectedDate Accepts the exception dates\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\nfunction checkDate(tempDate, expectedDate) {\n  var temp = expectedDate.slice(0);\n  var data;\n  var maxDate = calendarUtil.getMonthDaysCount(tempDate);\n  data = temp.shift();\n  while (data) {\n    if (data < 0) {\n      data = data + maxDate + 1;\n    }\n    if (data === tempDate.getDate()) {\n      return false;\n    }\n    data = temp.shift();\n  }\n  return true;\n}\n/**\r\n * Internal method to check the year value\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number[]} expectedyearDay Accepts the exception dates in year\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\nfunction checkYear(tempDate, expectedyearDay) {\n  var temp = expectedyearDay.slice(0);\n  var data;\n  var yearDay = getYearDay(tempDate);\n  data = temp.shift();\n  while (data) {\n    if (data < 0) {\n      data = data + calendarUtil.getYearDaysCount(tempDate, 0) + 1;\n    }\n    if (data === yearDay) {\n      return false;\n    }\n    data = temp.shift();\n  }\n  return true;\n}\n/**\r\n * Internal method to get the year day\r\n *\r\n * @param {Date} currentDate Accepts the date value\r\n * @returns {number} Returns the boolean value\r\n * @private\r\n */\nfunction getYearDay(currentDate) {\n  if (!startDateCollection[calendarUtil.getFullYear(currentDate)]) {\n    startDateCollection[calendarUtil.getFullYear(currentDate)] = calendarUtil.getYearLastDate(currentDate, 0);\n  }\n  var tempDate = startDateCollection[calendarUtil.getFullYear(currentDate)];\n  var diff = currentDate.getTime() - tempDate.getTime();\n  return Math.ceil(diff / MS_PER_DAY);\n}\n/**\r\n * Internal method to validate monthly rule type\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {MonthlyType} Returns the monthly type object\r\n * @private\r\n */\nfunction validateMonthlyRuleType(ruleObject) {\n  if (ruleObject.monthDay.length && !ruleObject.day.length) {\n    return 'date';\n  } else if (!ruleObject.monthDay.length && ruleObject.day.length) {\n    return 'day';\n  }\n  return 'both';\n}\n/**\r\n * Internal method to re-order the week days based on first day of week\r\n *\r\n * @param {string[]} days Accepts the week days value\r\n * @returns {void}\r\n * @private\r\n */\nfunction rotate(days) {\n  var data = days.shift();\n  days.push(data);\n}\n/**\r\n * Internal method to set first day of week\r\n *\r\n * @param {string} day Accepts the first day string\r\n * @returns {void}\r\n * @private\r\n */\nfunction setFirstDayOfWeek(day) {\n  while (dayIndex[0] !== day) {\n    rotate(dayIndex);\n  }\n}\n/**\r\n * Internal method to validate recurrence rule\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\nfunction validateRules(tempDate, ruleObject) {\n  var state = true;\n  var expectedDays = ruleObject.day;\n  var expectedMonth = ruleObject.month;\n  var expectedDate = calendarUtil.getExpectedDays(tempDate, ruleObject.monthDay);\n  var expectedyearDay = ruleObject.yearDay;\n  ruleObject.validRules.forEach(function (rule) {\n    switch (rule) {\n      case 'BYDAY':\n        if (checkDayIndex(tempDate.getDay(), expectedDays)) {\n          state = false;\n        }\n        break;\n      case 'BYMONTH':\n        if (calendarUtil.checkMonth(tempDate, expectedMonth)) {\n          state = false;\n        }\n        break;\n      case 'BYMONTHDAY':\n        if (checkDate(tempDate, expectedDate)) {\n          state = false;\n        }\n        break;\n      case 'BYYEARDAY':\n        if (checkYear(tempDate, expectedyearDay)) {\n          state = false;\n        }\n        break;\n    }\n  });\n  return state;\n}\n/**\r\n * Internal method to get calendar util\r\n *\r\n * @param {CalendarType} calendarMode Accepts the calendar type object\r\n * @returns {CalendarUtil} Returns the calendar util object\r\n * @private\r\n */\nexport function getCalendarUtil(calendarMode) {\n  if (calendarMode === 'Islamic') {\n    return new Islamic();\n  }\n  return new Gregorian();\n}\nvar startDateCollection = {};\nvar tempExcludeDate;\nvar dayIndex = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nvar maxOccurrence;\nvar tempViewDate;\nvar calendarUtil;\nvar DAYINDEX = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\nvar MAXOCCURRENCE = 43;\nvar WEEKPOS = ['first', 'second', 'third', 'fourth', 'last'];\nvar TIMES = 'summaryTimes';\nvar ON = 'summaryOn';\nvar EVERY = 'every';\nvar UNTIL = 'summaryUntil';\nvar DAYS = 'summaryDay';\nvar WEEKS = 'summaryWeek';\nvar MONTHS = 'summaryMonth';\nvar YEARS = 'summaryYear';\nvar DAYINDEXOBJECT = {\n  SU: 'sun',\n  MO: 'mon',\n  TU: 'tue',\n  WE: 'wed',\n  TH: 'thu',\n  FR: 'fri',\n  SA: 'sat'\n};\n// To check string has number\nvar HASNUMBER = /\\d/;\n// To find the numbers in string\nvar REMOVENUMBERINSTRING = /[^A-Z]+/;\n// To split number and string\nvar SPLITNUMBERANDSTRING = /[a-z]+|[^a-z]+/gi;\n/**\r\n * Method to generate string from date\r\n *\r\n * @param {Date} date Accepts the date value\r\n * @returns {string} Returns the string value\r\n */\nexport function getRecurrenceStringFromDate(date) {\n  return [date.getUTCFullYear(), roundDateValues(date.getUTCMonth() + 1), roundDateValues(date.getUTCDate()), 'T', roundDateValues(date.getUTCHours()), roundDateValues(date.getUTCMinutes()), roundDateValues(date.getUTCSeconds()), 'Z'].join('');\n}\n/**\r\n * Internal method to round the date values\r\n *\r\n * @param {string | number} date Accepts the date value in either string or number format\r\n * @returns {string} Returns the date value in string format\r\n * @private\r\n */\nfunction roundDateValues(date) {\n  return ('0' + date).slice(-2);\n}","map":{"version":3,"names":["isNullOrUndefined","getDefaultDateObject","getValue","cldrData","MS_PER_DAY","addDays","resetTime","capitalizeFirstWord","Islamic","Gregorian","Timezone","generateSummary","rule","localeObject","locale","calendarType","ruleObject","extractObjectFromRule","summary","getConstant","EVERY","cldrObj","cldrObj1","calendarMode","toLowerCase","nameSpace1","nameSpace","interval","freq","DAYS","WEEKS","ON","day","forEach","index","DAYINDEXOBJECT","length","MONTHS","getMonthSummary","YEARS","month","toString","count","TIMES","until","tempDate","UNTIL","getDate","getMonth","getFullYear","localeObj","monthDay","pos","setPosition","WEEKPOS","generate","startDate","excludeDate","startDayOfWeek","maximumCount","viewDate","newTimezone","MAXOCCURRENCE","cacheDate","calendarUtil","getCalendarUtil","data","modifiedDate","Date","getTime","tempExcludeDate","split","tz","content","parsedDate","getDateFromRecurrenceDateString","add","push","setHours","recExceptionCount","tempViewDate","setDate","maxOccurrence","setFirstDayOfWeek","DAYINDEX","parseInt","end","dailyType","weeklyType","monthlyType","yearlyType","recDateString","substr","excludeDateHandler","date","zeroIndex","indexOf","getDateCount","Math","floor","endDate","expectedCount","state","expectedDays","compareDates","validateRules","getDay","getHours","weekState","wkstIndex","weekCollection","wkst","dayIndex","startDateDiff","weekstartDate","weekendDate","compareTempDate","insertDataCollection","getStartDateForWeek","ruleType","validateMonthlyRuleType","monthlyDayTypeProcessforMonthFreq","monthlyDayTypeProcess","monthlyDateTypeProcessforMonthFreq","monthlyDateTypeProcess","typeValue","checkYearlyType","processWeekNo","processYearDay","stDate","getYearLastDate","startDay","firstWeekSpan","weekNos","weekNo","maxDate","minDate","insertDateCollection","insertDatasIntoExistingCollection","dateCollection","yearDay","getLeapYearDaysCount","isLeapYear","getYearDaysCount","initializeRecRuleVariables","ruleData","monthCollection","mainDate","monthInit","setMonth","currentMonthDate","getMonthStartDate","isSameYear","checkMonth","processDateCollectionForByMonthDay","beginDate","setNextValidDate","setValidDate","setFullYear","isLastMonth","getMonthDaysCount","recRuleVariables","isByMonth","validateProperDate","monthData","addYears","getMonthCollection","dates","isHavingNumber","map","item","HASNUMBER","test","j","expectedDaysArray","match","SPLITNUMBERANDSTRING","position","isSameMonth","isNaN","filterDateCollectionByIndex","insertDateCollectionBasedonBySetPos","dayCycleData","processWeekDays","initialDate","datas","week","row","insertDateCollectionBasedonIndex","processDateCollectionforByDayWithInteger","compareMonth","newstr","getDayString","currentDate","i","getRecurrenceCollection","recurrenceCollectionObject","expectedDaysArrays","arrPosition","getDateCollectionforBySetPosNull","recurrenceCollections","dayData","chDate","weekCount","year","firstDayOfWeek","firstOfMonth","lastOfMonth","numberOfDaysInMonth","firstWeekDay","used","ceil","sort","weekIndex","validRules","replace","REMOVENUMBERINSTRING","checkDayIndex","sortedExpectedDays","element","expectedDaysNumberSplit","expectedDaysArr","rules","rulesList","splitData","temp","Number","splice","dayCycle","startIndex","checkDate","expectedDate","slice","shift","checkYear","expectedyearDay","getYearDay","startDateCollection","diff","rotate","days","expectedMonth","getExpectedDays","SU","MO","TU","WE","TH","FR","SA","getRecurrenceStringFromDate","getUTCFullYear","roundDateValues","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","join"],"sources":["C:/Users/User/Desktop/ClinicaDentalVersionFinal/Proyecto-Clinica-Dental/donto-react/node_modules/@syncfusion/ej2-schedule/src/recurrence-editor/date-generator.js"],"sourcesContent":["/* eslint-disable max-len */\r\nimport { isNullOrUndefined, getDefaultDateObject, getValue, cldrData } from '@syncfusion/ej2-base';\r\nimport { MS_PER_DAY, addDays, resetTime, capitalizeFirstWord } from '../schedule/base/util';\r\nimport { Islamic, Gregorian } from '../common/calendar-util';\r\nimport { Timezone } from '../schedule/timezone/timezone';\r\n/**\r\n * Date Generator from Recurrence Rule\r\n */\r\n/**\r\n * Generate Summary from Recurrence Rule\r\n *\r\n * @param {string} rule Accepts the Recurrence rule\r\n * @param {L10n} localeObject Accepts the locale object\r\n * @param {string} locale Accepts the locale name\r\n * @param {CalendarType} calendarType Accepts the calendar type\r\n * @returns {string} Returns the summary string from given recurrence rule\r\n */\r\nexport function generateSummary(rule, localeObject, locale, calendarType) {\r\n    if (calendarType === void 0) { calendarType = 'Gregorian'; }\r\n    var ruleObject = extractObjectFromRule(rule);\r\n    var summary = localeObject.getConstant(EVERY) + ' ';\r\n    var cldrObj;\r\n    var cldrObj1;\r\n    var calendarMode = calendarType.toLowerCase();\r\n    if (locale === 'en' || locale === 'en-US') {\r\n        var nameSpace1 = 'months.stand-alone.abbreviated';\r\n        var nameSpace = 'days.stand-alone.abbreviated';\r\n        cldrObj1 = (getValue(nameSpace1, getDefaultDateObject(calendarMode)));\r\n        cldrObj = (getValue(nameSpace, getDefaultDateObject(calendarMode)));\r\n    }\r\n    else {\r\n        var nameSpace1 = 'main.' + locale + '.dates.calendars.' + calendarMode + '.months.stand-alone.abbreviated';\r\n        var nameSpace = 'main.' + locale + '.dates.calendars.' + calendarMode + '.days.stand-alone.abbreviated';\r\n        cldrObj1 =\r\n            (getValue(nameSpace1, cldrData));\r\n        cldrObj =\r\n            (getValue(nameSpace, cldrData));\r\n    }\r\n    if (ruleObject.interval > 1) {\r\n        summary += ruleObject.interval + ' ';\r\n    }\r\n    switch (ruleObject.freq) {\r\n        case 'DAILY':\r\n            summary += localeObject.getConstant(DAYS);\r\n            break;\r\n        case 'WEEKLY':\r\n            summary += localeObject.getConstant(WEEKS) + ' ' + localeObject.getConstant(ON) + ' ';\r\n            ruleObject.day.forEach(function (day, index) {\r\n                summary += capitalizeFirstWord(getValue(DAYINDEXOBJECT[\"\" + day], cldrObj), 'single');\r\n                summary += (((ruleObject.day.length - 1) === index) ? '' : ', ');\r\n            });\r\n            break;\r\n        case 'MONTHLY':\r\n            summary += localeObject.getConstant(MONTHS) + ' ' + localeObject.getConstant(ON) + ' ';\r\n            summary += getMonthSummary(ruleObject, cldrObj, localeObject);\r\n            break;\r\n        case 'YEARLY':\r\n            summary += localeObject.getConstant(YEARS) + ' ' + localeObject.getConstant(ON) + ' ';\r\n            summary += capitalizeFirstWord(getValue((ruleObject.month[0]).toString(), cldrObj1), 'single') + ' ';\r\n            summary += getMonthSummary(ruleObject, cldrObj, localeObject);\r\n            break;\r\n    }\r\n    if (ruleObject.count) {\r\n        summary += ', ' + (ruleObject.count) + ' ' + localeObject.getConstant(TIMES);\r\n    }\r\n    else if (ruleObject.until) {\r\n        var tempDate = ruleObject.until;\r\n        summary += ', ' + localeObject.getConstant(UNTIL)\r\n            + ' ' + tempDate.getDate()\r\n            + ' ' + capitalizeFirstWord(getValue((tempDate.getMonth() + 1).toString(), cldrObj1), 'single')\r\n            + ' ' + tempDate.getFullYear();\r\n    }\r\n    return summary;\r\n}\r\n/**\r\n * Generates Month summary\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {string[]} cldrObj Accepts the collections of month name from calendar\r\n * @param {L10n} localeObj Accepts the locale object\r\n * @returns {string} Returns the month summary string from given recurrence rule object\r\n * @private\r\n */\r\nfunction getMonthSummary(ruleObject, cldrObj, localeObj) {\r\n    var summary = '';\r\n    if (ruleObject.monthDay.length) {\r\n        summary += ruleObject.monthDay[0];\r\n    }\r\n    else if (ruleObject.day) {\r\n        var pos = ruleObject.setPosition - 1;\r\n        summary += localeObj.getConstant(WEEKPOS[pos > -1 ? pos : (WEEKPOS.length - 1)])\r\n            + ' ' + capitalizeFirstWord(getValue(DAYINDEXOBJECT[ruleObject.day[0]], cldrObj), 'single');\r\n    }\r\n    return summary;\r\n}\r\n/**\r\n * Generates the date collections from the given recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the rule start date\r\n * @param {string} rule Accepts the recurrence rule\r\n * @param {string} excludeDate Accepts the exception dates in string format\r\n * @param {number} startDayOfWeek Accepts the start day index of week\r\n * @param {number} maximumCount Accepts the maximum number count to generate date collections\r\n * @param {Date} viewDate Accepts the current date instead of start date\r\n * @param {CalendarType} calendarMode Accepts the calendar type\r\n * @param {string} newTimezone Accepts the timezone name\r\n * @returns {number[]} Returns the collection of dates\r\n */\r\nexport function generate(startDate, rule, excludeDate, startDayOfWeek, maximumCount, viewDate, calendarMode, newTimezone) {\r\n    if (maximumCount === void 0) { maximumCount = MAXOCCURRENCE; }\r\n    if (viewDate === void 0) { viewDate = null; }\r\n    if (calendarMode === void 0) { calendarMode = 'Gregorian'; }\r\n    if (newTimezone === void 0) { newTimezone = null; }\r\n    var ruleObject = extractObjectFromRule(rule);\r\n    var cacheDate;\r\n    calendarUtil = getCalendarUtil(calendarMode);\r\n    var data = [];\r\n    var modifiedDate = new Date(startDate.getTime());\r\n    tempExcludeDate = [];\r\n    var tempDate = isNullOrUndefined(excludeDate) ? [] : excludeDate.split(',');\r\n    var tz = new Timezone();\r\n    tempDate.forEach(function (content) {\r\n        var parsedDate = getDateFromRecurrenceDateString(content);\r\n        if (newTimezone) {\r\n            parsedDate = tz.add(new Date(parsedDate.getTime()), newTimezone);\r\n        }\r\n        tempExcludeDate.push(new Date(parsedDate.getTime()).setHours(0, 0, 0, 0));\r\n    });\r\n    ruleObject.recExceptionCount = !isNullOrUndefined(ruleObject.count) ? tempExcludeDate.length : 0;\r\n    if (viewDate && viewDate > startDate && !ruleObject.count) {\r\n        tempViewDate = new Date(new Date(viewDate.getTime()).setHours(0, 0, 0));\r\n    }\r\n    else {\r\n        tempViewDate = null;\r\n    }\r\n    if (!ruleObject.until && tempViewDate) {\r\n        cacheDate = new Date(tempViewDate.getTime());\r\n        cacheDate.setDate(tempViewDate.getDate() + maximumCount * (ruleObject.interval));\r\n        ruleObject.until = cacheDate;\r\n    }\r\n    if (ruleObject.until && startDate > ruleObject.until) {\r\n        return data;\r\n    }\r\n    maxOccurrence = maximumCount;\r\n    setFirstDayOfWeek(DAYINDEX[parseInt(startDayOfWeek.toString(), 10)]);\r\n    if (ruleObject.until) {\r\n        var end = resetTime(ruleObject.until);\r\n        ruleObject.until = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 23, 59, 59);\r\n    }\r\n    switch (ruleObject.freq) {\r\n        case 'DAILY':\r\n            dailyType(modifiedDate, ruleObject.until, data, ruleObject);\r\n            break;\r\n        case 'WEEKLY':\r\n            weeklyType(modifiedDate, ruleObject.until, data, ruleObject);\r\n            break;\r\n        case 'MONTHLY':\r\n            monthlyType(modifiedDate, ruleObject.until, data, ruleObject);\r\n            break;\r\n        case 'YEARLY':\r\n            yearlyType(modifiedDate, ruleObject.until, data, ruleObject);\r\n    }\r\n    return data;\r\n}\r\n/**\r\n * Generate date object from given date string\r\n *\r\n * @param {string} recDateString Accepts the exception date as string\r\n * @returns {Date} Returns the date from exception date string\r\n */\r\nexport function getDateFromRecurrenceDateString(recDateString) {\r\n    return new Date(recDateString.substr(0, 4) +\r\n        '-' + recDateString.substr(4, 2) +\r\n        '-' + recDateString.substr(6, 5) +\r\n        ':' + recDateString.substr(11, 2) +\r\n        ':' + recDateString.substr(13));\r\n}\r\n/**\r\n * Internal method to handle exclude date\r\n *\r\n * @param {number[]} data Accepts the exception date collections\r\n * @param {number} date Accepts the new exclude date\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction excludeDateHandler(data, date) {\r\n    var zeroIndex = new Date(date).setHours(0, 0, 0, 0);\r\n    if (tempExcludeDate.indexOf(zeroIndex) === -1 && (!tempViewDate || zeroIndex >= tempViewDate.getTime())) {\r\n        data.push(date);\r\n    }\r\n}\r\n/**\r\n * Internal method for get date count\r\n *\r\n * @param {Date} startDate Accepts the date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {number} Returns the number of date count\r\n * @private\r\n */\r\nfunction getDateCount(startDate, ruleObject) {\r\n    var count = maxOccurrence;\r\n    if (ruleObject.count) {\r\n        count = ruleObject.count;\r\n    }\r\n    else if (ruleObject.until) {\r\n        if (ruleObject.freq === 'DAILY' || ruleObject.freq === 'WEEKLY') {\r\n            count = Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1;\r\n        }\r\n        else if (ruleObject.freq === 'MONTHLY' || ruleObject.freq === 'YEARLY') {\r\n            count = Math.floor(((ruleObject.until.getMonth() + 12 * ruleObject.until.getFullYear()) -\r\n                (startDate.getMonth() + 12 * startDate.getFullYear())) / ruleObject.interval) +\r\n                (ruleObject.day.length > 1 ? (Math.floor((ruleObject.until.getTime() - startDate.getTime()) / MS_PER_DAY) + 1) : 1);\r\n            if (ruleObject.freq === 'YEARLY') {\r\n                count = ruleObject.month.length > 1 ? (count * ruleObject.month.length) : count;\r\n            }\r\n        }\r\n    }\r\n    return count;\r\n}\r\n/**\r\n *  Internal method for daily type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction dailyType(startDate, endDate, data, ruleObject) {\r\n    var tempDate = new Date(startDate.getTime());\r\n    var interval = ruleObject.interval;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var state;\r\n    var expectedDays = ruleObject.day;\r\n    while (compareDates(tempDate, endDate)) {\r\n        state = true;\r\n        state = validateRules(tempDate, ruleObject);\r\n        if (state && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1 || expectedDays.length === 0)) {\r\n            excludeDateHandler(data, tempDate.getTime());\r\n            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                break;\r\n            }\r\n        }\r\n        tempDate.setDate(tempDate.getDate() + interval);\r\n        if (tempDate.getHours() !== startDate.getHours()) {\r\n            tempDate.setHours(startDate.getHours());\r\n        }\r\n    }\r\n}\r\n/**\r\n * Internal method for weekly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction weeklyType(startDate, endDate, data, ruleObject) {\r\n    var tempDate = new Date(startDate.getTime());\r\n    if (!ruleObject.day.length) {\r\n        ruleObject.day.push(DAYINDEX[startDate.getDay()]);\r\n    }\r\n    var interval = ruleObject.interval;\r\n    var expectedDays = ruleObject.day;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var weekState = true;\r\n    var wkstIndex;\r\n    var weekCollection = [];\r\n    if (expectedDays.length > 1) {\r\n        if (isNullOrUndefined(ruleObject.wkst) || ruleObject.wkst === '') {\r\n            ruleObject.wkst = dayIndex[0];\r\n        }\r\n        wkstIndex = DAYINDEX.indexOf(ruleObject.wkst);\r\n        while (compareDates(tempDate, endDate)) {\r\n            var startDateDiff = DAYINDEX.indexOf(DAYINDEX[tempDate.getDay()]) - wkstIndex;\r\n            startDateDiff = startDateDiff === -1 ? 6 : startDateDiff;\r\n            var weekstartDate = addDays(tempDate, -startDateDiff);\r\n            var weekendDate = addDays(weekstartDate, 6);\r\n            var compareTempDate = new Date(tempDate.getTime());\r\n            weekendDate = resetTime(weekendDate);\r\n            compareTempDate = resetTime(compareTempDate);\r\n            while (weekendDate >= compareTempDate) {\r\n                if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\r\n                    weekCollection.push([tempDate.getTime()]);\r\n                }\r\n                if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                    break;\r\n                }\r\n                tempDate.setDate(tempDate.getDate() + 1);\r\n                if (tempDate.getHours() !== startDate.getHours()) {\r\n                    tempDate.setHours(startDate.getHours());\r\n                }\r\n                compareTempDate = new Date(tempDate.getTime());\r\n                compareTempDate = resetTime(compareTempDate);\r\n            }\r\n            tempDate.setDate(tempDate.getDate() - 1);\r\n            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                break;\r\n            }\r\n            tempDate.setDate((tempDate.getDate()) + 1 + ((interval - 1) * 7));\r\n            insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\r\n            weekCollection = [];\r\n        }\r\n    }\r\n    else {\r\n        tempDate = getStartDateForWeek(startDate, ruleObject.day);\r\n        while (compareDates(tempDate, endDate)) {\r\n            weekState = validateRules(tempDate, ruleObject);\r\n            if (weekState && (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1)) {\r\n                excludeDateHandler(data, tempDate.getTime());\r\n            }\r\n            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                break;\r\n            }\r\n            tempDate.setDate(tempDate.getDate() + (interval * 7));\r\n        }\r\n        insertDataCollection(weekCollection, weekState, startDate, endDate, data, ruleObject);\r\n        weekCollection = [];\r\n    }\r\n}\r\n/**\r\n *  Internal method for monthly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyType(startDate, endDate, data, ruleObject) {\r\n    // Set monthday value if BYDAY, BYMONTH and Month day property is not set based on start date\r\n    if (!ruleObject.month.length && !ruleObject.day.length && !ruleObject.monthDay.length) {\r\n        ruleObject.monthDay.push(startDate.getDate());\r\n        if (ruleObject.freq === 'YEARLY') {\r\n            ruleObject.month.push(startDate.getMonth() + 1);\r\n        }\r\n    }\r\n    else if (ruleObject.month.length > 0 && !ruleObject.day.length && !ruleObject.monthDay.length) {\r\n        ruleObject.monthDay.push(startDate.getDate());\r\n    }\r\n    var ruleType = validateMonthlyRuleType(ruleObject);\r\n    switch (ruleType) {\r\n        case 'day':\r\n            switch (ruleObject.freq) {\r\n                case 'MONTHLY':\r\n                    monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\r\n                    break;\r\n                case 'YEARLY':\r\n                    monthlyDayTypeProcess(startDate, endDate, data, ruleObject);\r\n                    break;\r\n            }\r\n            break;\r\n        case 'both':\r\n        case 'date':\r\n            switch (ruleObject.freq) {\r\n                case 'MONTHLY':\r\n                    monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\r\n                    break;\r\n                case 'YEARLY':\r\n                    monthlyDateTypeProcess(startDate, endDate, data, ruleObject);\r\n                    break;\r\n            }\r\n            break;\r\n    }\r\n}\r\n/**\r\n * Internal method for yearly type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction yearlyType(startDate, endDate, data, ruleObject) {\r\n    var typeValue = checkYearlyType(ruleObject);\r\n    switch (typeValue) {\r\n        case 'MONTH':\r\n            monthlyType(startDate, endDate, data, ruleObject);\r\n            break;\r\n        case 'WEEKNO':\r\n            processWeekNo(startDate, endDate, data, ruleObject);\r\n            break;\r\n        case 'YEARDAY':\r\n            processYearDay(startDate, endDate, data, ruleObject);\r\n            break;\r\n    }\r\n}\r\n/**\r\n * Internal method for process week no\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction processWeekNo(startDate, endDate, data, ruleObject) {\r\n    var stDate = calendarUtil.getYearLastDate(startDate, 0);\r\n    var tempDate;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var state;\r\n    var startDay;\r\n    var firstWeekSpan;\r\n    var weekNos = ruleObject.weekNo;\r\n    var weekNo;\r\n    var maxDate;\r\n    var minDate;\r\n    var weekCollection = [];\r\n    var expectedDays = ruleObject.day;\r\n    while (compareDates(stDate, endDate)) {\r\n        startDay = dayIndex.indexOf(DAYINDEX[stDate.getDay()]);\r\n        firstWeekSpan = (6 - startDay) + 1;\r\n        for (var index = 0; index < weekNos.length; index++) {\r\n            weekNo = weekNos[parseInt(index.toString(), 10)];\r\n            weekNo = (weekNo > 0) ? weekNo : 53 + weekNo + 1;\r\n            maxDate = (weekNo === 1) ? firstWeekSpan : firstWeekSpan + ((weekNo - 1) * 7);\r\n            minDate = (weekNo === 1) ? firstWeekSpan - 7 : firstWeekSpan + ((weekNo - 2) * 7);\r\n            while (minDate < maxDate) {\r\n                tempDate = new Date(stDate.getTime() + (MS_PER_DAY * minDate));\r\n                if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\r\n                    if (isNullOrUndefined(ruleObject.setPosition)) {\r\n                        insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\r\n                    }\r\n                    else {\r\n                        weekCollection.push([tempDate.getTime()]);\r\n                    }\r\n                }\r\n                minDate++;\r\n            }\r\n        }\r\n        if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n            insertDatasIntoExistingCollection(weekCollection, state, startDate, endDate, data, ruleObject);\r\n        }\r\n        if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n            return;\r\n        }\r\n        stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\r\n        weekCollection = [];\r\n    }\r\n}\r\n/**\r\n * Internal method for process year day\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction processYearDay(startDate, endDate, data, ruleObject) {\r\n    var stDate = calendarUtil.getYearLastDate(startDate, 0);\r\n    var tempDate;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var state;\r\n    var dateCollection = [];\r\n    var date;\r\n    var expectedDays = ruleObject.day;\r\n    while (compareDates(stDate, endDate)) {\r\n        for (var index = 0; index < ruleObject.yearDay.length; index++) {\r\n            date = ruleObject.yearDay[parseInt(index.toString(), 10)];\r\n            tempDate = new Date(stDate.getTime());\r\n            if ((date === calendarUtil.getLeapYearDaysCount() || date === -calendarUtil.getLeapYearDaysCount()) &&\r\n                (!calendarUtil.isLeapYear(calendarUtil.getFullYear(tempDate), 1))) {\r\n                tempDate.setDate(tempDate.getDate() + 1);\r\n                continue;\r\n            }\r\n            tempDate.setDate(tempDate.getDate() + ((date < 0) ?\r\n                calendarUtil.getYearDaysCount(tempDate, 1) + 1 + date : date));\r\n            if (expectedDays.length === 0 || expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\r\n                if (ruleObject.setPosition == null) {\r\n                    insertDateCollection(state, startDate, endDate, data, ruleObject, tempDate.getTime());\r\n                }\r\n                else {\r\n                    dateCollection.push([tempDate.getTime()]);\r\n                }\r\n            }\r\n        }\r\n        if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n            insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject);\r\n        }\r\n        if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n            return;\r\n        }\r\n        stDate = calendarUtil.getYearLastDate(tempDate, ruleObject.interval);\r\n        dateCollection = [];\r\n    }\r\n}\r\n/**\r\n * Internal method to check yearly type\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {YearRuleType} Returns the Yearly rule type object\r\n * @private\r\n */\r\nfunction checkYearlyType(ruleObject) {\r\n    if (ruleObject.yearDay.length) {\r\n        return 'YEARDAY';\r\n    }\r\n    else if (ruleObject.weekNo.length) {\r\n        return 'WEEKNO';\r\n    }\r\n    return 'MONTH';\r\n}\r\n/**\r\n * Internal method to initialize recurrence rule variables\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {RuleData} Return the rule data object\r\n * @private\r\n */\r\nfunction initializeRecRuleVariables(startDate, ruleObject) {\r\n    var ruleData = {\r\n        monthCollection: [],\r\n        index: 0,\r\n        tempDate: new Date(startDate.getTime()),\r\n        mainDate: new Date(startDate.getTime()),\r\n        expectedCount: getDateCount(startDate, ruleObject),\r\n        monthInit: 0,\r\n        dateCollection: []\r\n    };\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(ruleData.tempDate, ruleObject.month[0], ruleData.tempDate.getDate());\r\n    }\r\n    return ruleData;\r\n}\r\n/**\r\n * Internal method for process monthly date type recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyDateTypeProcess(startDate, endDate, data, ruleObject) {\r\n    if (ruleObject.month.length) {\r\n        monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\r\n        return;\r\n    }\r\n    var ruleData = initializeRecRuleVariables(startDate, ruleObject);\r\n    var currentMonthDate;\r\n    ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\r\n    while (compareDates(ruleData.tempDate, endDate)) {\r\n        currentMonthDate = new Date(ruleData.tempDate.getTime());\r\n        while (calendarUtil.isSameYear(currentMonthDate, ruleData.tempDate) &&\r\n            (ruleData.expectedCount && (data.length + ruleObject.recExceptionCount) <= ruleData.expectedCount)) {\r\n            if (ruleObject.month.length === 0 || (ruleObject.month.length > 0\r\n                && !calendarUtil.checkMonth(ruleData.tempDate, ruleObject.month))) {\r\n                processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, false);\r\n                ruleData.beginDate = new Date(ruleData.tempDate.getTime());\r\n                ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\r\n            }\r\n            else {\r\n                calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\r\n                ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\r\n                break;\r\n            }\r\n        }\r\n        ruleData.tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\r\n        insertDataCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\r\n        if (calendarUtil.isLastMonth(ruleData.tempDate)) {\r\n            calendarUtil.setValidDate(ruleData.tempDate, 1, 1);\r\n            ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\r\n        }\r\n        if (ruleData.expectedCount && (data.length + ruleObject.recExceptionCount) >= ruleData.expectedCount) {\r\n            return;\r\n        }\r\n        ruleData.tempDate.setFullYear(ruleData.tempDate.getFullYear() + ruleObject.interval - 1);\r\n        ruleData.tempDate = getStartDateForWeek(ruleData.tempDate, ruleObject.day);\r\n        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\r\n        ruleData.dateCollection = [];\r\n    }\r\n}\r\n/**\r\n * Internal method for process monthly date type with month frequency from recurrence rule\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyDateTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\r\n    var ruleData = initializeRecRuleVariables(startDate, ruleObject);\r\n    ruleData.tempDate = ruleData.mainDate = calendarUtil.getMonthStartDate(ruleData.tempDate);\r\n    if (((ruleObject.freq === 'MONTHLY' && ruleObject.interval === 12) || (ruleObject.freq === 'YEARLY')) &&\r\n        calendarUtil.getMonthDaysCount(startDate) < ruleObject.monthDay[0]) {\r\n        return;\r\n    }\r\n    while (compareDates(ruleData.tempDate, endDate)) {\r\n        ruleData.beginDate = new Date(ruleData.tempDate.getTime());\r\n        processDateCollectionForByMonthDay(ruleObject, ruleData, endDate, true, startDate, data);\r\n        if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n            insertDatasIntoExistingCollection(ruleData.dateCollection, ruleData.state, startDate, endDate, data, ruleObject);\r\n        }\r\n        if (ruleData.expectedCount && (data.length + ruleObject.recExceptionCount) >= ruleData.expectedCount) {\r\n            return;\r\n        }\r\n        ruleData.monthInit = setNextValidDate(ruleData.tempDate, ruleObject, ruleData.monthInit, ruleData.beginDate);\r\n        ruleData.dateCollection = [];\r\n    }\r\n}\r\n/**\r\n * To process date collection for Monthly & Yearly based on BYMONTH Day property\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {RuleData} recRuleVariables Accepts the rule data\r\n * @param {Date} endDate Accepts the end date\r\n * @param {boolean} isByMonth Accepts the boolean to validate either month or not\r\n * @param {Date} startDate Accepts the start date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction processDateCollectionForByMonthDay(ruleObject, recRuleVariables, endDate, isByMonth, startDate, data) {\r\n    for (var index = 0; index < ruleObject.monthDay.length; index++) {\r\n        recRuleVariables.date = ruleObject.monthDay[parseInt(index.toString(), 10)];\r\n        recRuleVariables.tempDate = calendarUtil.getMonthStartDate(recRuleVariables.tempDate);\r\n        var maxDate = calendarUtil.getMonthDaysCount(recRuleVariables.tempDate);\r\n        recRuleVariables.date = recRuleVariables.date > 0 ? recRuleVariables.date : (maxDate + recRuleVariables.date + 1);\r\n        if (validateProperDate(recRuleVariables.tempDate, recRuleVariables.date, recRuleVariables.mainDate)\r\n            && (recRuleVariables.date > 0)) {\r\n            calendarUtil.setDate(recRuleVariables.tempDate, recRuleVariables.date);\r\n            if (endDate && recRuleVariables.tempDate > endDate) {\r\n                return;\r\n            }\r\n            if (ruleObject.day.length === 0 || ruleObject.day.indexOf(DAYINDEX[recRuleVariables.tempDate.getDay()]) > -1) {\r\n                if (isByMonth && isNullOrUndefined(ruleObject.setPosition) && (recRuleVariables.expectedCount\r\n                    && (data.length + ruleObject.recExceptionCount) < recRuleVariables.expectedCount)) {\r\n                    insertDateCollection(recRuleVariables.state, startDate, endDate, data, ruleObject, recRuleVariables.tempDate.getTime());\r\n                }\r\n                else {\r\n                    recRuleVariables.dateCollection.push([recRuleVariables.tempDate.getTime()]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Internal method to set next valid date\r\n *\r\n * @param {Date} tempDate Accepts the date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} monthInit Accepts the initial month\r\n * @param {Date} beginDate Accepts the initial date\r\n * @param {number} interval Accepts the interval duration\r\n * @returns {number} Returnx the next valid date\r\n * @private\r\n */\r\nfunction setNextValidDate(tempDate, ruleObject, monthInit, beginDate, interval) {\r\n    if (beginDate === void 0) { beginDate = null; }\r\n    var monthData = beginDate ? beginDate.getMonth() : 0;\r\n    var startDate = calendarUtil.getMonthStartDate(tempDate);\r\n    interval = isNullOrUndefined(interval) ? ruleObject.interval : interval;\r\n    tempDate.setFullYear(startDate.getFullYear());\r\n    tempDate.setMonth(startDate.getMonth());\r\n    tempDate.setDate(startDate.getDate());\r\n    if (ruleObject.month.length) {\r\n        monthInit++;\r\n        monthInit = monthInit % ruleObject.month.length;\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[parseInt(monthInit.toString(), 10)], 1);\r\n        if (monthInit === 0) {\r\n            calendarUtil.addYears(tempDate, interval, ruleObject.month[0]);\r\n        }\r\n    }\r\n    else {\r\n        if (beginDate && (beginDate.getFullYear() < tempDate.getFullYear())) {\r\n            monthData = tempDate.getMonth() - 1;\r\n        }\r\n        calendarUtil.setValidDate(tempDate, interval, 1, monthData, beginDate);\r\n    }\r\n    return monthInit;\r\n}\r\n/**\r\n * To get month collection when BYDAY property having more than one value in list.\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction getMonthCollection(startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    var tempDate = new Date(startDate.getTime());\r\n    tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n    var monthCollection = [];\r\n    var dateCollection = [];\r\n    var dates = [];\r\n    var index;\r\n    var state;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var monthInit = 0;\r\n    var beginDate;\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\r\n    }\r\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n    while (compareDates(tempDate, endDate)\r\n        && (expectedCount && (data.length + ruleObject.recExceptionCount) < expectedCount)) {\r\n        var currentMonthDate = new Date(tempDate.getTime());\r\n        var isHavingNumber = expectedDays.map(function (item) { return HASNUMBER.test(item); });\r\n        if (isHavingNumber.indexOf(true) > -1) {\r\n            for (var j = 0; j <= expectedDays.length - 1; j++) {\r\n                var expectedDaysArray = expectedDays[parseInt(j.toString(), 10)].match(SPLITNUMBERANDSTRING);\r\n                var position = parseInt(expectedDaysArray[0], 10);\r\n                tempDate = new Date(tempDate.getTime());\r\n                tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n                tempDate = getStartDateForWeek(tempDate, expectedDays);\r\n                currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\r\n                while (calendarUtil.isSameYear(currentMonthDate, tempDate) && calendarUtil.isSameMonth(currentMonthDate, tempDate)) {\r\n                    if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentMonthDate.getDay()]) {\r\n                        monthCollection.push([currentMonthDate.getTime()]);\r\n                    }\r\n                    currentMonthDate.setDate(currentMonthDate.getDate() + (1));\r\n                }\r\n                currentMonthDate.setDate(currentMonthDate.getDate() - (1));\r\n                if (expectedDaysArray[0].indexOf('-') > -1) {\r\n                    index = monthCollection.length - (-1 * position);\r\n                }\r\n                else {\r\n                    index = position - 1;\r\n                }\r\n                index = isNaN(index) ? 0 : index;\r\n                if (monthCollection.length > 0) {\r\n                    if (isNullOrUndefined(ruleObject.setPosition)) {\r\n                        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\r\n                    }\r\n                    else {\r\n                        dateCollection = [(filterDateCollectionByIndex(monthCollection, index, dates))];\r\n                    }\r\n                }\r\n                if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                    return;\r\n                }\r\n                monthCollection = [];\r\n            }\r\n            if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n                insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\r\n                dates = [];\r\n            }\r\n            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\r\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n            monthCollection = [];\r\n        }\r\n        else {\r\n            var weekCollection = [];\r\n            var dayCycleData = processWeekDays(expectedDays);\r\n            currentMonthDate.setFullYear(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate());\r\n            var initialDate = new Date(tempDate.getTime());\r\n            beginDate = new Date(tempDate.getTime());\r\n            while (calendarUtil.isSameMonth(initialDate, tempDate)) {\r\n                weekCollection.push(tempDate.getTime());\r\n                if (expectedDays.indexOf(DAYINDEX[tempDate.getDay()]) > -1) {\r\n                    monthCollection.push(weekCollection);\r\n                    weekCollection = [];\r\n                }\r\n                tempDate.setDate(tempDate.getDate()\r\n                    + dayCycleData[DAYINDEX[tempDate.getDay()]]);\r\n            }\r\n            index = ((ruleObject.setPosition < 1) ? (monthCollection.length + ruleObject.setPosition) : ruleObject.setPosition - 1);\r\n            if (isNullOrUndefined(ruleObject.setPosition)) {\r\n                index = 0;\r\n                var datas = [];\r\n                for (var week = 0; week < monthCollection.length; week++) {\r\n                    for (var row = 0; row < monthCollection[parseInt(week.toString(), 10)].length; row++) {\r\n                        datas.push(monthCollection[parseInt(week.toString(), 10)][parseInt(row.toString(), 10)]);\r\n                    }\r\n                }\r\n                monthCollection = [datas];\r\n            }\r\n            if (monthCollection.length > 0) {\r\n                insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\r\n            }\r\n            if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                return;\r\n            }\r\n            monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\r\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n            monthCollection = [];\r\n        }\r\n    }\r\n}\r\n/**\r\n * To process monday day type for FREQ=MONTHLY\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    // When BYDAY property having more than 1 value.\r\n    if (expectedDays.length > 1) {\r\n        getMonthCollection(startDate, endDate, data, ruleObject);\r\n        return;\r\n    }\r\n    var tempDate = new Date(startDate.getTime());\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var monthCollection = [];\r\n    var beginDate;\r\n    var monthInit = 0;\r\n    tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\r\n    }\r\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n    while (compareDates(tempDate, endDate) && (expectedCount && (data.length + ruleObject.recExceptionCount) < expectedCount)) {\r\n        beginDate = new Date(tempDate.getTime());\r\n        var currentMonthDate = new Date(tempDate.getTime());\r\n        while (calendarUtil.isSameMonth(tempDate, currentMonthDate)) {\r\n            monthCollection.push([currentMonthDate.getTime()]);\r\n            currentMonthDate.setDate(currentMonthDate.getDate() + (7));\r\n        }\r\n        // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\r\n        insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\r\n        monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate);\r\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n        monthCollection = [];\r\n    }\r\n}\r\n/**\r\n * To process monday day type for FREQ=YEARLY\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction monthlyDayTypeProcess(startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    var isHavingNumber = expectedDays.map(function (item) { return HASNUMBER.test(item); });\r\n    // If BYDAY property having more than 1 value in list\r\n    if (expectedDays.length > 1 && isHavingNumber.indexOf(true) > -1) {\r\n        processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject);\r\n        return;\r\n    }\r\n    else if (ruleObject.month.length && expectedDays.length === 1 && isHavingNumber.indexOf(true) > -1) {\r\n        monthlyDayTypeProcessforMonthFreq(startDate, endDate, data, ruleObject);\r\n        return;\r\n    }\r\n    var tempDate = new Date(startDate.getTime());\r\n    var currentMonthDate;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var interval = ruleObject.interval;\r\n    var monthCollection = [];\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\r\n    }\r\n    // Set the date as start date of the yeear if yearly freq having ByDay property alone\r\n    if (isNullOrUndefined(ruleObject.setPosition) && ruleObject.month.length === 0 && ruleObject.weekNo.length === 0) {\r\n        tempDate.setFullYear(startDate.getFullYear(), 0, 1);\r\n    }\r\n    tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n    while (compareDates(tempDate, endDate)) {\r\n        currentMonthDate = new Date(tempDate.getTime());\r\n        while (calendarUtil.isSameYear(currentMonthDate, tempDate) &&\r\n            (expectedCount && (data.length + ruleObject.recExceptionCount) <= expectedCount)) {\r\n            currentMonthDate = new Date(tempDate.getTime());\r\n            while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\r\n                if (ruleObject.month.length === 0 || (ruleObject.month.length > 0\r\n                    && !calendarUtil.checkMonth(tempDate, ruleObject.month))) {\r\n                    if (expectedDays.length > 1) {\r\n                        if (calendarUtil.compareMonth(currentMonthDate, tempDate)) {\r\n                            calendarUtil.setValidDate(tempDate, 1, 1);\r\n                            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                            break;\r\n                        }\r\n                        if (expectedDays.indexOf(DAYINDEX[currentMonthDate.getDay()]) > -1) {\r\n                            monthCollection.push([currentMonthDate.getTime()]);\r\n                        }\r\n                        currentMonthDate.setDate(currentMonthDate.getDate() + (1));\r\n                    }\r\n                    else {\r\n                        // If BYDAY property having 1 value in list\r\n                        if (currentMonthDate.getFullYear() > tempDate.getFullYear()) {\r\n                            calendarUtil.setValidDate(tempDate, 1, 1);\r\n                            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                            break;\r\n                        }\r\n                        var newstr = getDayString(expectedDays[0]);\r\n                        if (DAYINDEX[currentMonthDate.getDay()] === newstr\r\n                            && new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), 0)\r\n                                > new Date(startDate.getFullYear())) {\r\n                            monthCollection.push([currentMonthDate.getTime()]);\r\n                        }\r\n                        currentMonthDate.setDate(currentMonthDate.getDate() + (7));\r\n                    }\r\n                }\r\n                else {\r\n                    calendarUtil.setValidDate(tempDate, 1, 1);\r\n                    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        tempDate.setFullYear(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), currentMonthDate.getDate());\r\n        // To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\r\n        insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject);\r\n        if (calendarUtil.isLastMonth(tempDate)) {\r\n            calendarUtil.setValidDate(tempDate, 1, 1);\r\n            tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n        }\r\n        tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\r\n        if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n            return;\r\n        }\r\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n        monthCollection = [];\r\n    }\r\n}\r\n/**\r\n * To process the recurrence rule when BYDAY property having values with integer\r\n *\r\n * @param {Date} startDate Accepts the strat date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of dates\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction processDateCollectionforByDayWithInteger(startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var tempDate = new Date(startDate.getTime());\r\n    var interval = ruleObject.interval;\r\n    var monthCollection = [];\r\n    var dateCollection = [];\r\n    var index;\r\n    var state;\r\n    var monthInit = 0;\r\n    var currentMonthDate;\r\n    var currentDate;\r\n    var beginDate;\r\n    tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n    var datas = [];\r\n    if (ruleObject.month.length) {\r\n        calendarUtil.setMonth(tempDate, ruleObject.month[0], 1);\r\n    }\r\n    tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n    while (compareDates(tempDate, endDate)) {\r\n        currentMonthDate = new Date(tempDate.getTime());\r\n        for (var i = 0; i <= ruleObject.month.length; i++) {\r\n            for (var j = 0; j <= expectedDays.length - 1; j++) {\r\n                tempDate = calendarUtil.getMonthStartDate(tempDate);\r\n                tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                monthCollection = [];\r\n                while (calendarUtil.isSameYear(currentMonthDate, tempDate) &&\r\n                    (expectedCount && (data.length + ruleObject.recExceptionCount) <= expectedCount)) {\r\n                    while (calendarUtil.isSameYear(currentMonthDate, tempDate)) {\r\n                        currentMonthDate = new Date(tempDate.getTime());\r\n                        if (ruleObject.month.length === 0 ||\r\n                            (ruleObject.month.length > 0 && ruleObject.month[parseInt(i.toString(), 10)] === calendarUtil.getMonth(currentMonthDate))) {\r\n                            var expectedDaysArray = expectedDays[parseInt(j.toString(), 10)].match(SPLITNUMBERANDSTRING);\r\n                            var position = parseInt(expectedDaysArray[0], 10);\r\n                            currentDate = new Date(tempDate.getTime());\r\n                            while (calendarUtil.isSameYear(currentDate, tempDate)\r\n                                && calendarUtil.isSameMonth(currentDate, tempDate)) {\r\n                                if (expectedDaysArray[expectedDaysArray.length - 1] === DAYINDEX[currentDate.getDay()]) {\r\n                                    monthCollection.push([currentDate.getTime()]);\r\n                                }\r\n                                currentDate.setDate(currentDate.getDate() + (1));\r\n                            }\r\n                            currentDate.setDate(currentDate.getDate() - (1));\r\n                            if (expectedDaysArray[0].indexOf('-') > -1) {\r\n                                index = monthCollection.length - (-1 * position);\r\n                            }\r\n                            else {\r\n                                index = position - 1;\r\n                            }\r\n                            index = isNaN(index) ? 0 : index;\r\n                        }\r\n                        monthInit = setNextValidDate(tempDate, ruleObject, monthInit, beginDate, 1);\r\n                        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n                    }\r\n                }\r\n                tempDate = j === 0 && currentDate ? new Date(currentDate.getTime()) : new Date(currentMonthDate.getTime());\r\n                if (monthCollection.length > 0) {\r\n                    if (isNullOrUndefined(ruleObject.setPosition)) {\r\n                        insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\r\n                    }\r\n                    else {\r\n                        dateCollection = [(filterDateCollectionByIndex(monthCollection, index, datas))];\r\n                    }\r\n                }\r\n                if (expectedCount && (data.length + ruleObject.recExceptionCount) >= expectedCount) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        if (!isNullOrUndefined(ruleObject.setPosition)) {\r\n            insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\r\n            datas = [];\r\n        }\r\n        if (calendarUtil.isLastMonth(tempDate)) {\r\n            calendarUtil.setValidDate(tempDate, 1, 1);\r\n            tempDate.setFullYear(tempDate.getFullYear() + interval - 1);\r\n        }\r\n        else {\r\n            tempDate.setFullYear(tempDate.getFullYear() + interval);\r\n        }\r\n        tempDate = getStartDateForWeek(tempDate, ruleObject.day);\r\n        if (ruleObject.month.length) {\r\n            calendarUtil.setMonth(tempDate, ruleObject.month[0], tempDate.getDate());\r\n        }\r\n    }\r\n}\r\n/**\r\n * To get recurrence collection if BYSETPOS is null\r\n *\r\n * @param {number[]} monthCollection Accepts the month collection dates\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {RuleData} Returns the rule data object\r\n * @private\r\n */\r\nfunction getRecurrenceCollection(monthCollection, expectedDays) {\r\n    var index;\r\n    var recurrenceCollectionObject = { monthCollection: [], index: 0 };\r\n    if (expectedDays.length === 1) {\r\n        // To split numeric value from BYDAY property value\r\n        var expectedDaysArrays = expectedDays[0].match(SPLITNUMBERANDSTRING);\r\n        var arrPosition = void 0;\r\n        if (expectedDaysArrays.length > 1) {\r\n            arrPosition = parseInt(expectedDaysArrays[0], 10);\r\n            index = ((arrPosition < 1) ? (monthCollection.length + arrPosition) : arrPosition - 1);\r\n        }\r\n        else {\r\n            index = 0;\r\n            monthCollection = getDateCollectionforBySetPosNull(monthCollection);\r\n        }\r\n    }\r\n    else {\r\n        index = 0;\r\n        monthCollection = getDateCollectionforBySetPosNull(monthCollection);\r\n    }\r\n    recurrenceCollectionObject.monthCollection = monthCollection;\r\n    recurrenceCollectionObject.index = index;\r\n    return recurrenceCollectionObject;\r\n}\r\n/**\r\n * Internal method to process the data collections\r\n *\r\n * @param {number[]} dateCollection Accepts the date collections\r\n * @param {boolean} state Accepts the state\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of numbers\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDataCollection(dateCollection, state, startDate, endDate, data, ruleObject) {\r\n    var index = ((ruleObject.setPosition < 1) ?\r\n        (dateCollection.length + ruleObject.setPosition) : ruleObject.setPosition - 1);\r\n    if (isNullOrUndefined(ruleObject.setPosition)) {\r\n        index = 0;\r\n        dateCollection = getDateCollectionforBySetPosNull(dateCollection);\r\n    }\r\n    if (dateCollection.length > 0) {\r\n        insertDatasIntoExistingCollection(dateCollection, state, startDate, endDate, data, ruleObject, index);\r\n    }\r\n}\r\n/**\r\n * To process month collection if BYSETPOS is null\r\n *\r\n * @param {number[]} monthCollection Accepts the month date collections\r\n * @returns {number[]} Returns the month date collections\r\n * @private\r\n */\r\nfunction getDateCollectionforBySetPosNull(monthCollection) {\r\n    var datas = [];\r\n    for (var week = 0; week < monthCollection.length; week++) {\r\n        for (var row = 0; row < monthCollection[parseInt(week.toString(), 10)].length; row++) {\r\n            datas.push(new Date(monthCollection[parseInt(week.toString(), 10)][parseInt(row.toString(), 10)]).getTime());\r\n        }\r\n    }\r\n    monthCollection = datas.length > 0 ? [datas] : [];\r\n    return monthCollection;\r\n}\r\n/**\r\n * To filter date collection based on BYDAY Index, then BYSETPOS and to insert datas into existing collection\r\n *\r\n * @param {number[]} monthCollection Accepts the month date collections\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the date collections\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDateCollectionBasedonIndex(monthCollection, startDate, endDate, data, ruleObject) {\r\n    var expectedDays = ruleObject.day;\r\n    var state;\r\n    var datas = [];\r\n    var dateCollection = [];\r\n    var recurrenceCollections = getRecurrenceCollection(monthCollection, expectedDays);\r\n    monthCollection = recurrenceCollections.monthCollection;\r\n    var index = recurrenceCollections.index;\r\n    if (ruleObject.setPosition != null) {\r\n        dateCollection = [(filterDateCollectionByIndex(monthCollection, index, datas))];\r\n        insertDateCollectionBasedonBySetPos(dateCollection, state, startDate, endDate, data, ruleObject);\r\n    }\r\n    else {\r\n        if (monthCollection.length > 0) {\r\n            insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index);\r\n        }\r\n    }\r\n    datas = [];\r\n}\r\n/**\r\n * To filter date collection when BYDAY property having values with number\r\n *\r\n * @param {number[]} monthCollection Accepts the date collections\r\n * @param {number} index Accepts the index of date collections\r\n * @param {number[]} datas Accepts the collection of dates\r\n * @returns {number[]} Returns the collection of dates\r\n * @private\r\n */\r\nfunction filterDateCollectionByIndex(monthCollection, index, datas) {\r\n    for (var week = 0; week < monthCollection[parseInt(index.toString(), 10)].length; week++) {\r\n        datas.push(monthCollection[parseInt(index.toString(), 10)][parseInt(week.toString(), 10)]);\r\n    }\r\n    return datas;\r\n}\r\n/**\r\n * To insert processed date collection in final array element\r\n *\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} dayData Accepts the date index\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDateCollection(state, startDate, endDate, data, ruleObject, dayData) {\r\n    var expectedCount = getDateCount(startDate, ruleObject);\r\n    var chDate = new Date(dayData);\r\n    state = validateRules(chDate, ruleObject);\r\n    if ((chDate >= startDate) && compareDates(chDate, endDate) && state\r\n        && expectedCount && (data.length + ruleObject.recExceptionCount) < expectedCount) {\r\n        excludeDateHandler(data, dayData);\r\n    }\r\n}\r\n/**\r\n * Return the last week number of given month and year.\r\n *\r\n * @param {number} year Accepts the Year in number format\r\n * @param {number} startDayOfWeek Accepts the start date\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {number} week Accepts the week in number format\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {number} returns week number\r\n * @private\r\n */\r\nfunction weekCount(year, startDayOfWeek, monthCollection, week, ruleObject) {\r\n    var firstDayOfWeek = startDayOfWeek || 0;\r\n    var firstOfMonth = new Date(year, ruleObject.month[0] - 1, 1);\r\n    var lastOfMonth = new Date(year, ruleObject.month[0], 0);\r\n    var numberOfDaysInMonth = lastOfMonth.getDate();\r\n    var firstWeekDay = (firstOfMonth.getDay() - firstDayOfWeek + 7) % 7;\r\n    var used = firstWeekDay + numberOfDaysInMonth;\r\n    var count = Math.ceil(used / 7) - 1;\r\n    var dayData = monthCollection[parseInt(week.toString(), 10)][parseInt(count.toString(), 10)];\r\n    var chDate = new Date(dayData);\r\n    var state = validateRules(chDate, ruleObject);\r\n    return (state) ? count : count - 1;\r\n}\r\n/**\r\n * To process date collection based on Byset position after process the collection based on BYDAY property value index: EX:BYDAY=1SUm-1SU\r\n *\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDateCollectionBasedonBySetPos(monthCollection, state, startDate, endDate, data, ruleObject) {\r\n    if (monthCollection.length > 0) {\r\n        for (var week = 0; week < monthCollection.length; week++) {\r\n            monthCollection[parseInt(week.toString(), 10)].sort();\r\n            var expectedDays = ruleObject.day;\r\n            var isHavingNumber = expectedDays.map(function (item) { return HASNUMBER.test(item); });\r\n            var weekIndex = (ruleObject.freq === 'YEARLY' && (ruleObject.validRules.indexOf('BYMONTH') > -1) &&\r\n                !(isHavingNumber.indexOf(true) > -1)) ?\r\n                weekCount(new Date(monthCollection[0][0]).getFullYear(), 0, monthCollection, week, ruleObject)\r\n                : (monthCollection[parseInt(week.toString(), 10)].length + ruleObject.setPosition);\r\n            var index = ((ruleObject.setPosition < 1) ? weekIndex : ruleObject.setPosition - 1);\r\n            var dayData = monthCollection[parseInt(week.toString(), 10)][parseInt(index.toString(), 10)];\r\n            insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\r\n        }\r\n    }\r\n}\r\n/**\r\n * To insert datas into existing collection which is processed from previous loop.\r\n *\r\n * @param {number[]} monthCollection Accepts the collection of dates\r\n * @param {boolean} state Accepts the state of the recurrence rule\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @param {number[]} data Accepts the collection of date\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @param {number} index Accepts the index value\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction insertDatasIntoExistingCollection(monthCollection, state, startDate, endDate, data, ruleObject, index) {\r\n    if (monthCollection.length > 0) {\r\n        index = !isNullOrUndefined(index) ? index :\r\n            ((ruleObject.setPosition < 1)\r\n                ? (monthCollection.length + ruleObject.setPosition) : ruleObject.setPosition - 1);\r\n        monthCollection[parseInt(index.toString(), 10)].sort();\r\n        for (var week = 0; week < monthCollection[parseInt(index.toString(), 10)].length; week++) {\r\n            var dayData = monthCollection[parseInt(index.toString(), 10)][parseInt(week.toString(), 10)];\r\n            insertDateCollection(state, startDate, endDate, data, ruleObject, dayData);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Internal method to compare dates\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {Date} endDate Accepts the end date\r\n * @returns {boolean} Returns the result of checking start and end dates\r\n * @private\r\n */\r\nfunction compareDates(startDate, endDate) {\r\n    return endDate ? (startDate <= endDate) : true;\r\n}\r\n/**\r\n * Internal method to get day string\r\n *\r\n * @param {string} expectedDays Accepts the exception date string\r\n * @returns {string} Returns the valid string\r\n * @private\r\n */\r\nfunction getDayString(expectedDays) {\r\n    // To get BYDAY value without numeric value\r\n    var newstr = expectedDays.replace(REMOVENUMBERINSTRING, '');\r\n    return newstr;\r\n}\r\n/**\r\n * Internal method to check day index\r\n *\r\n * @param {number} day Accepts the day index\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {boolean} Returns the index date\r\n * @private\r\n */\r\nfunction checkDayIndex(day, expectedDays) {\r\n    var sortedExpectedDays = [];\r\n    expectedDays.forEach(function (element) {\r\n        var expectedDaysNumberSplit = element.match(SPLITNUMBERANDSTRING);\r\n        if (expectedDaysNumberSplit.length === 2) {\r\n            sortedExpectedDays.push(expectedDaysNumberSplit[1]);\r\n        }\r\n        else {\r\n            sortedExpectedDays.push(expectedDaysNumberSplit[0]);\r\n        }\r\n    });\r\n    return (sortedExpectedDays.indexOf(DAYINDEX[parseInt(day.toString(), 10)]) === -1);\r\n}\r\n/**\r\n * Internal method to get start date of week\r\n *\r\n * @param {Date} startDate Accepts the start date\r\n * @param {string[]} expectedDays Accepts the exception dates\r\n * @returns {Date} Return the week start date\r\n * @private\r\n */\r\nfunction getStartDateForWeek(startDate, expectedDays) {\r\n    var tempDate = new Date(startDate.getTime());\r\n    var newstr;\r\n    if (expectedDays.length > 0) {\r\n        var expectedDaysArr = [];\r\n        for (var i = 0; i <= expectedDays.length - 1; i++) {\r\n            newstr = getDayString(expectedDays[parseInt(i.toString(), 10)]);\r\n            expectedDaysArr.push(newstr);\r\n        }\r\n        if (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1) {\r\n            do {\r\n                tempDate.setDate(tempDate.getDate() + 1);\r\n            } while (expectedDaysArr.indexOf(DAYINDEX[tempDate.getDay()]) === -1);\r\n        }\r\n    }\r\n    return tempDate;\r\n}\r\n/**\r\n * Method to generate recurrence rule object from given rule\r\n *\r\n * @param {string} rules Accepts the recurrence rule\r\n * @returns {RecRule} Returns the recurrence rule object\r\n */\r\nexport function extractObjectFromRule(rules) {\r\n    var ruleObject = {\r\n        freq: null,\r\n        interval: 1,\r\n        count: null,\r\n        until: null,\r\n        day: [],\r\n        wkst: null,\r\n        month: [],\r\n        weekNo: [],\r\n        monthDay: [],\r\n        yearDay: [],\r\n        setPosition: null,\r\n        validRules: []\r\n    };\r\n    var rulesList = rules.split(';');\r\n    var splitData = [];\r\n    var temp;\r\n    rulesList.forEach(function (data) {\r\n        splitData = data.split('=');\r\n        switch (splitData[0]) {\r\n            case 'UNTIL':\r\n                temp = splitData[1];\r\n                ruleObject.until = getDateFromRecurrenceDateString(temp);\r\n                break;\r\n            case 'BYDAY':\r\n                ruleObject.day = splitData[1].split(',');\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'BYMONTHDAY':\r\n                ruleObject.monthDay = splitData[1].split(',').map(Number);\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'BYMONTH':\r\n                ruleObject.month = splitData[1].split(',').map(Number);\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'BYYEARDAY':\r\n                ruleObject.yearDay = splitData[1].split(',').map(Number);\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'BYWEEKNO':\r\n                ruleObject.weekNo = splitData[1].split(',').map(Number);\r\n                ruleObject.validRules.push(splitData[0]);\r\n                break;\r\n            case 'INTERVAL':\r\n                ruleObject.interval = parseInt(splitData[1], 10);\r\n                break;\r\n            case 'COUNT':\r\n                ruleObject.count = parseInt(splitData[1], 10);\r\n                break;\r\n            case 'BYSETPOS':\r\n                ruleObject.setPosition = parseInt(splitData[1], 10) > 4 ? -1 : parseInt(splitData[1], 10);\r\n                break;\r\n            case 'FREQ':\r\n                ruleObject.freq = splitData[1];\r\n                break;\r\n            case 'WKST':\r\n                ruleObject.wkst = splitData[1];\r\n                break;\r\n        }\r\n    });\r\n    if ((ruleObject.freq === 'MONTHLY') && (ruleObject.monthDay.length === 0)) {\r\n        var index = ruleObject.validRules.indexOf('BYDAY');\r\n        ruleObject.validRules.splice(index, 1);\r\n    }\r\n    return ruleObject;\r\n}\r\n/**\r\n * Internal method to validate proper date\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number} data Accepts the data value\r\n * @param {Date} startDate Accepts the start date\r\n * @returns {boolean} Returns the result of date validate\r\n * @private\r\n */\r\nfunction validateProperDate(tempDate, data, startDate) {\r\n    var maxDate = calendarUtil.getMonthDaysCount(tempDate);\r\n    return (data <= maxDate) && (tempDate >= startDate);\r\n}\r\n/**\r\n * Internal method to process week days\r\n *\r\n * @param {string[]} expectedDays Accepts the expection dates\r\n * @returns {Object} Returns the weekdays object\r\n * @private\r\n */\r\nfunction processWeekDays(expectedDays) {\r\n    var dayCycle = {};\r\n    expectedDays.forEach(function (element, index) {\r\n        if (index === expectedDays.length - 1) {\r\n            var startIndex = dayIndex.indexOf(element);\r\n            var temp = startIndex;\r\n            while (temp % 7 !== dayIndex.indexOf(expectedDays[0])) {\r\n                temp++;\r\n            }\r\n            dayCycle[\"\" + element] = temp - startIndex;\r\n        }\r\n        else {\r\n            dayCycle[\"\" + element] = dayIndex.indexOf(expectedDays[(index + 1)]) - dayIndex.indexOf(element);\r\n        }\r\n    });\r\n    return dayCycle;\r\n}\r\n/**\r\n * Internal method to check date\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number[]} expectedDate Accepts the exception dates\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\r\nfunction checkDate(tempDate, expectedDate) {\r\n    var temp = expectedDate.slice(0);\r\n    var data;\r\n    var maxDate = calendarUtil.getMonthDaysCount(tempDate);\r\n    data = temp.shift();\r\n    while (data) {\r\n        if (data < 0) {\r\n            data = data + maxDate + 1;\r\n        }\r\n        if (data === tempDate.getDate()) {\r\n            return false;\r\n        }\r\n        data = temp.shift();\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Internal method to check the year value\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {number[]} expectedyearDay Accepts the exception dates in year\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\r\nfunction checkYear(tempDate, expectedyearDay) {\r\n    var temp = expectedyearDay.slice(0);\r\n    var data;\r\n    var yearDay = getYearDay(tempDate);\r\n    data = temp.shift();\r\n    while (data) {\r\n        if (data < 0) {\r\n            data = data + calendarUtil.getYearDaysCount(tempDate, 0) + 1;\r\n        }\r\n        if (data === yearDay) {\r\n            return false;\r\n        }\r\n        data = temp.shift();\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Internal method to get the year day\r\n *\r\n * @param {Date} currentDate Accepts the date value\r\n * @returns {number} Returns the boolean value\r\n * @private\r\n */\r\nfunction getYearDay(currentDate) {\r\n    if (!startDateCollection[calendarUtil.getFullYear(currentDate)]) {\r\n        startDateCollection[calendarUtil.getFullYear(currentDate)] = calendarUtil.getYearLastDate(currentDate, 0);\r\n    }\r\n    var tempDate = startDateCollection[calendarUtil.getFullYear(currentDate)];\r\n    var diff = currentDate.getTime() - tempDate.getTime();\r\n    return Math.ceil(diff / MS_PER_DAY);\r\n}\r\n/**\r\n * Internal method to validate monthly rule type\r\n *\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {MonthlyType} Returns the monthly type object\r\n * @private\r\n */\r\nfunction validateMonthlyRuleType(ruleObject) {\r\n    if (ruleObject.monthDay.length && !ruleObject.day.length) {\r\n        return 'date';\r\n    }\r\n    else if (!ruleObject.monthDay.length && ruleObject.day.length) {\r\n        return 'day';\r\n    }\r\n    return 'both';\r\n}\r\n/**\r\n * Internal method to re-order the week days based on first day of week\r\n *\r\n * @param {string[]} days Accepts the week days value\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction rotate(days) {\r\n    var data = days.shift();\r\n    days.push(data);\r\n}\r\n/**\r\n * Internal method to set first day of week\r\n *\r\n * @param {string} day Accepts the first day string\r\n * @returns {void}\r\n * @private\r\n */\r\nfunction setFirstDayOfWeek(day) {\r\n    while (dayIndex[0] !== day) {\r\n        rotate(dayIndex);\r\n    }\r\n}\r\n/**\r\n * Internal method to validate recurrence rule\r\n *\r\n * @param {Date} tempDate Accepts the date value\r\n * @param {RecRule} ruleObject Accepts the recurrence rule object\r\n * @returns {boolean} Returns the boolean value\r\n * @private\r\n */\r\nfunction validateRules(tempDate, ruleObject) {\r\n    var state = true;\r\n    var expectedDays = ruleObject.day;\r\n    var expectedMonth = ruleObject.month;\r\n    var expectedDate = calendarUtil.getExpectedDays(tempDate, ruleObject.monthDay);\r\n    var expectedyearDay = ruleObject.yearDay;\r\n    ruleObject.validRules.forEach(function (rule) {\r\n        switch (rule) {\r\n            case 'BYDAY':\r\n                if (checkDayIndex(tempDate.getDay(), expectedDays)) {\r\n                    state = false;\r\n                }\r\n                break;\r\n            case 'BYMONTH':\r\n                if (calendarUtil.checkMonth(tempDate, expectedMonth)) {\r\n                    state = false;\r\n                }\r\n                break;\r\n            case 'BYMONTHDAY':\r\n                if (checkDate(tempDate, expectedDate)) {\r\n                    state = false;\r\n                }\r\n                break;\r\n            case 'BYYEARDAY':\r\n                if (checkYear(tempDate, expectedyearDay)) {\r\n                    state = false;\r\n                }\r\n                break;\r\n        }\r\n    });\r\n    return state;\r\n}\r\n/**\r\n * Internal method to get calendar util\r\n *\r\n * @param {CalendarType} calendarMode Accepts the calendar type object\r\n * @returns {CalendarUtil} Returns the calendar util object\r\n * @private\r\n */\r\nexport function getCalendarUtil(calendarMode) {\r\n    if (calendarMode === 'Islamic') {\r\n        return new Islamic();\r\n    }\r\n    return new Gregorian();\r\n}\r\nvar startDateCollection = {};\r\nvar tempExcludeDate;\r\nvar dayIndex = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\r\nvar maxOccurrence;\r\nvar tempViewDate;\r\nvar calendarUtil;\r\nvar DAYINDEX = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\r\nvar MAXOCCURRENCE = 43;\r\nvar WEEKPOS = ['first', 'second', 'third', 'fourth', 'last'];\r\nvar TIMES = 'summaryTimes';\r\nvar ON = 'summaryOn';\r\nvar EVERY = 'every';\r\nvar UNTIL = 'summaryUntil';\r\nvar DAYS = 'summaryDay';\r\nvar WEEKS = 'summaryWeek';\r\nvar MONTHS = 'summaryMonth';\r\nvar YEARS = 'summaryYear';\r\nvar DAYINDEXOBJECT = {\r\n    SU: 'sun',\r\n    MO: 'mon',\r\n    TU: 'tue',\r\n    WE: 'wed',\r\n    TH: 'thu',\r\n    FR: 'fri',\r\n    SA: 'sat'\r\n};\r\n// To check string has number\r\nvar HASNUMBER = /\\d/;\r\n// To find the numbers in string\r\nvar REMOVENUMBERINSTRING = /[^A-Z]+/;\r\n// To split number and string\r\nvar SPLITNUMBERANDSTRING = /[a-z]+|[^a-z]+/gi;\r\n/**\r\n * Method to generate string from date\r\n *\r\n * @param {Date} date Accepts the date value\r\n * @returns {string} Returns the string value\r\n */\r\nexport function getRecurrenceStringFromDate(date) {\r\n    return [date.getUTCFullYear(),\r\n        roundDateValues(date.getUTCMonth() + 1),\r\n        roundDateValues(date.getUTCDate()),\r\n        'T',\r\n        roundDateValues(date.getUTCHours()),\r\n        roundDateValues(date.getUTCMinutes()),\r\n        roundDateValues(date.getUTCSeconds()),\r\n        'Z'].join('');\r\n}\r\n/**\r\n * Internal method to round the date values\r\n *\r\n * @param {string | number} date Accepts the date value in either string or number format\r\n * @returns {string} Returns the date value in string format\r\n * @private\r\n */\r\nfunction roundDateValues(date) {\r\n    return ('0' + date).slice(-2);\r\n}\r\n"],"mappings":"AAAA;AACA,SAASA,iBAAiB,EAAEC,oBAAoB,EAAEC,QAAQ,EAAEC,QAAQ,QAAQ,sBAAsB;AAClG,SAASC,UAAU,EAAEC,OAAO,EAAEC,SAAS,EAAEC,mBAAmB,QAAQ,uBAAuB;AAC3F,SAASC,OAAO,EAAEC,SAAS,QAAQ,yBAAyB;AAC5D,SAASC,QAAQ,QAAQ,+BAA+B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACC,IAAI,EAAEC,YAAY,EAAEC,MAAM,EAAEC,YAAY,EAAE;EACtE,IAAIA,YAAY,KAAK,KAAK,CAAC,EAAE;IAAEA,YAAY,GAAG,WAAW;EAAE;EAC3D,IAAIC,UAAU,GAAGC,qBAAqB,CAACL,IAAI,CAAC;EAC5C,IAAIM,OAAO,GAAGL,YAAY,CAACM,WAAW,CAACC,KAAK,CAAC,GAAG,GAAG;EACnD,IAAIC,OAAO;EACX,IAAIC,QAAQ;EACZ,IAAIC,YAAY,GAAGR,YAAY,CAACS,WAAW,CAAC,CAAC;EAC7C,IAAIV,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAK,OAAO,EAAE;IACvC,IAAIW,UAAU,GAAG,gCAAgC;IACjD,IAAIC,SAAS,GAAG,8BAA8B;IAC9CJ,QAAQ,GAAIpB,QAAQ,CAACuB,UAAU,EAAExB,oBAAoB,CAACsB,YAAY,CAAC,CAAE;IACrEF,OAAO,GAAInB,QAAQ,CAACwB,SAAS,EAAEzB,oBAAoB,CAACsB,YAAY,CAAC,CAAE;EACvE,CAAC,MACI;IACD,IAAIE,UAAU,GAAG,OAAO,GAAGX,MAAM,GAAG,mBAAmB,GAAGS,YAAY,GAAG,iCAAiC;IAC1G,IAAIG,SAAS,GAAG,OAAO,GAAGZ,MAAM,GAAG,mBAAmB,GAAGS,YAAY,GAAG,+BAA+B;IACvGD,QAAQ,GACHpB,QAAQ,CAACuB,UAAU,EAAEtB,QAAQ,CAAE;IACpCkB,OAAO,GACFnB,QAAQ,CAACwB,SAAS,EAAEvB,QAAQ,CAAE;EACvC;EACA,IAAIa,UAAU,CAACW,QAAQ,GAAG,CAAC,EAAE;IACzBT,OAAO,IAAIF,UAAU,CAACW,QAAQ,GAAG,GAAG;EACxC;EACA,QAAQX,UAAU,CAACY,IAAI;IACnB,KAAK,OAAO;MACRV,OAAO,IAAIL,YAAY,CAACM,WAAW,CAACU,IAAI,CAAC;MACzC;IACJ,KAAK,QAAQ;MACTX,OAAO,IAAIL,YAAY,CAACM,WAAW,CAACW,KAAK,CAAC,GAAG,GAAG,GAAGjB,YAAY,CAACM,WAAW,CAACY,EAAE,CAAC,GAAG,GAAG;MACrFf,UAAU,CAACgB,GAAG,CAACC,OAAO,CAAC,UAAUD,GAAG,EAAEE,KAAK,EAAE;QACzChB,OAAO,IAAIX,mBAAmB,CAACL,QAAQ,CAACiC,cAAc,CAAC,EAAE,GAAGH,GAAG,CAAC,EAAEX,OAAO,CAAC,EAAE,QAAQ,CAAC;QACrFH,OAAO,IAAOF,UAAU,CAACgB,GAAG,CAACI,MAAM,GAAG,CAAC,KAAMF,KAAK,GAAI,EAAE,GAAG,IAAK;MACpE,CAAC,CAAC;MACF;IACJ,KAAK,SAAS;MACVhB,OAAO,IAAIL,YAAY,CAACM,WAAW,CAACkB,MAAM,CAAC,GAAG,GAAG,GAAGxB,YAAY,CAACM,WAAW,CAACY,EAAE,CAAC,GAAG,GAAG;MACtFb,OAAO,IAAIoB,eAAe,CAACtB,UAAU,EAAEK,OAAO,EAAER,YAAY,CAAC;MAC7D;IACJ,KAAK,QAAQ;MACTK,OAAO,IAAIL,YAAY,CAACM,WAAW,CAACoB,KAAK,CAAC,GAAG,GAAG,GAAG1B,YAAY,CAACM,WAAW,CAACY,EAAE,CAAC,GAAG,GAAG;MACrFb,OAAO,IAAIX,mBAAmB,CAACL,QAAQ,CAAEc,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,CAAEC,QAAQ,CAAC,CAAC,EAAEnB,QAAQ,CAAC,EAAE,QAAQ,CAAC,GAAG,GAAG;MACpGJ,OAAO,IAAIoB,eAAe,CAACtB,UAAU,EAAEK,OAAO,EAAER,YAAY,CAAC;MAC7D;EACR;EACA,IAAIG,UAAU,CAAC0B,KAAK,EAAE;IAClBxB,OAAO,IAAI,IAAI,GAAIF,UAAU,CAAC0B,KAAM,GAAG,GAAG,GAAG7B,YAAY,CAACM,WAAW,CAACwB,KAAK,CAAC;EAChF,CAAC,MACI,IAAI3B,UAAU,CAAC4B,KAAK,EAAE;IACvB,IAAIC,QAAQ,GAAG7B,UAAU,CAAC4B,KAAK;IAC/B1B,OAAO,IAAI,IAAI,GAAGL,YAAY,CAACM,WAAW,CAAC2B,KAAK,CAAC,GAC3C,GAAG,GAAGD,QAAQ,CAACE,OAAO,CAAC,CAAC,GACxB,GAAG,GAAGxC,mBAAmB,CAACL,QAAQ,CAAC,CAAC2C,QAAQ,CAACG,QAAQ,CAAC,CAAC,GAAG,CAAC,EAAEP,QAAQ,CAAC,CAAC,EAAEnB,QAAQ,CAAC,EAAE,QAAQ,CAAC,GAC7F,GAAG,GAAGuB,QAAQ,CAACI,WAAW,CAAC,CAAC;EACtC;EACA,OAAO/B,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoB,eAAeA,CAACtB,UAAU,EAAEK,OAAO,EAAE6B,SAAS,EAAE;EACrD,IAAIhC,OAAO,GAAG,EAAE;EAChB,IAAIF,UAAU,CAACmC,QAAQ,CAACf,MAAM,EAAE;IAC5BlB,OAAO,IAAIF,UAAU,CAACmC,QAAQ,CAAC,CAAC,CAAC;EACrC,CAAC,MACI,IAAInC,UAAU,CAACgB,GAAG,EAAE;IACrB,IAAIoB,GAAG,GAAGpC,UAAU,CAACqC,WAAW,GAAG,CAAC;IACpCnC,OAAO,IAAIgC,SAAS,CAAC/B,WAAW,CAACmC,OAAO,CAACF,GAAG,GAAG,CAAC,CAAC,GAAGA,GAAG,GAAIE,OAAO,CAAClB,MAAM,GAAG,CAAE,CAAC,CAAC,GAC1E,GAAG,GAAG7B,mBAAmB,CAACL,QAAQ,CAACiC,cAAc,CAACnB,UAAU,CAACgB,GAAG,CAAC,CAAC,CAAC,CAAC,EAAEX,OAAO,CAAC,EAAE,QAAQ,CAAC;EACnG;EACA,OAAOH,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASqC,QAAQA,CAACC,SAAS,EAAE5C,IAAI,EAAE6C,WAAW,EAAEC,cAAc,EAAEC,YAAY,EAAEC,QAAQ,EAAErC,YAAY,EAAEsC,WAAW,EAAE;EACtH,IAAIF,YAAY,KAAK,KAAK,CAAC,EAAE;IAAEA,YAAY,GAAGG,aAAa;EAAE;EAC7D,IAAIF,QAAQ,KAAK,KAAK,CAAC,EAAE;IAAEA,QAAQ,GAAG,IAAI;EAAE;EAC5C,IAAIrC,YAAY,KAAK,KAAK,CAAC,EAAE;IAAEA,YAAY,GAAG,WAAW;EAAE;EAC3D,IAAIsC,WAAW,KAAK,KAAK,CAAC,EAAE;IAAEA,WAAW,GAAG,IAAI;EAAE;EAClD,IAAI7C,UAAU,GAAGC,qBAAqB,CAACL,IAAI,CAAC;EAC5C,IAAImD,SAAS;EACbC,YAAY,GAAGC,eAAe,CAAC1C,YAAY,CAAC;EAC5C,IAAI2C,IAAI,GAAG,EAAE;EACb,IAAIC,YAAY,GAAG,IAAIC,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;EAChDC,eAAe,GAAG,EAAE;EACpB,IAAIzB,QAAQ,GAAG7C,iBAAiB,CAACyD,WAAW,CAAC,GAAG,EAAE,GAAGA,WAAW,CAACc,KAAK,CAAC,GAAG,CAAC;EAC3E,IAAIC,EAAE,GAAG,IAAI9D,QAAQ,CAAC,CAAC;EACvBmC,QAAQ,CAACZ,OAAO,CAAC,UAAUwC,OAAO,EAAE;IAChC,IAAIC,UAAU,GAAGC,+BAA+B,CAACF,OAAO,CAAC;IACzD,IAAIZ,WAAW,EAAE;MACba,UAAU,GAAGF,EAAE,CAACI,GAAG,CAAC,IAAIR,IAAI,CAACM,UAAU,CAACL,OAAO,CAAC,CAAC,CAAC,EAAER,WAAW,CAAC;IACpE;IACAS,eAAe,CAACO,IAAI,CAAC,IAAIT,IAAI,CAACM,UAAU,CAACL,OAAO,CAAC,CAAC,CAAC,CAACS,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EAC7E,CAAC,CAAC;EACF9D,UAAU,CAAC+D,iBAAiB,GAAG,CAAC/E,iBAAiB,CAACgB,UAAU,CAAC0B,KAAK,CAAC,GAAG4B,eAAe,CAAClC,MAAM,GAAG,CAAC;EAChG,IAAIwB,QAAQ,IAAIA,QAAQ,GAAGJ,SAAS,IAAI,CAACxC,UAAU,CAAC0B,KAAK,EAAE;IACvDsC,YAAY,GAAG,IAAIZ,IAAI,CAAC,IAAIA,IAAI,CAACR,QAAQ,CAACS,OAAO,CAAC,CAAC,CAAC,CAACS,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EAC3E,CAAC,MACI;IACDE,YAAY,GAAG,IAAI;EACvB;EACA,IAAI,CAAChE,UAAU,CAAC4B,KAAK,IAAIoC,YAAY,EAAE;IACnCjB,SAAS,GAAG,IAAIK,IAAI,CAACY,YAAY,CAACX,OAAO,CAAC,CAAC,CAAC;IAC5CN,SAAS,CAACkB,OAAO,CAACD,YAAY,CAACjC,OAAO,CAAC,CAAC,GAAGY,YAAY,GAAI3C,UAAU,CAACW,QAAS,CAAC;IAChFX,UAAU,CAAC4B,KAAK,GAAGmB,SAAS;EAChC;EACA,IAAI/C,UAAU,CAAC4B,KAAK,IAAIY,SAAS,GAAGxC,UAAU,CAAC4B,KAAK,EAAE;IAClD,OAAOsB,IAAI;EACf;EACAgB,aAAa,GAAGvB,YAAY;EAC5BwB,iBAAiB,CAACC,QAAQ,CAACC,QAAQ,CAAC3B,cAAc,CAACjB,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;EACpE,IAAIzB,UAAU,CAAC4B,KAAK,EAAE;IAClB,IAAI0C,GAAG,GAAGhF,SAAS,CAACU,UAAU,CAAC4B,KAAK,CAAC;IACrC5B,UAAU,CAAC4B,KAAK,GAAG,IAAIwB,IAAI,CAACkB,GAAG,CAACrC,WAAW,CAAC,CAAC,EAAEqC,GAAG,CAACtC,QAAQ,CAAC,CAAC,EAAEsC,GAAG,CAACvC,OAAO,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EAC7F;EACA,QAAQ/B,UAAU,CAACY,IAAI;IACnB,KAAK,OAAO;MACR2D,SAAS,CAACpB,YAAY,EAAEnD,UAAU,CAAC4B,KAAK,EAAEsB,IAAI,EAAElD,UAAU,CAAC;MAC3D;IACJ,KAAK,QAAQ;MACTwE,UAAU,CAACrB,YAAY,EAAEnD,UAAU,CAAC4B,KAAK,EAAEsB,IAAI,EAAElD,UAAU,CAAC;MAC5D;IACJ,KAAK,SAAS;MACVyE,WAAW,CAACtB,YAAY,EAAEnD,UAAU,CAAC4B,KAAK,EAAEsB,IAAI,EAAElD,UAAU,CAAC;MAC7D;IACJ,KAAK,QAAQ;MACT0E,UAAU,CAACvB,YAAY,EAAEnD,UAAU,CAAC4B,KAAK,EAAEsB,IAAI,EAAElD,UAAU,CAAC;EACpE;EACA,OAAOkD,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASS,+BAA+BA,CAACgB,aAAa,EAAE;EAC3D,OAAO,IAAIvB,IAAI,CAACuB,aAAa,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GACtC,GAAG,GAAGD,aAAa,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GAChC,GAAG,GAAGD,aAAa,CAACC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,GAChC,GAAG,GAAGD,aAAa,CAACC,MAAM,CAAC,EAAE,EAAE,CAAC,CAAC,GACjC,GAAG,GAAGD,aAAa,CAACC,MAAM,CAAC,EAAE,CAAC,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAAC3B,IAAI,EAAE4B,IAAI,EAAE;EACpC,IAAIC,SAAS,GAAG,IAAI3B,IAAI,CAAC0B,IAAI,CAAC,CAAChB,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACnD,IAAIR,eAAe,CAAC0B,OAAO,CAACD,SAAS,CAAC,KAAK,CAAC,CAAC,KAAK,CAACf,YAAY,IAAIe,SAAS,IAAIf,YAAY,CAACX,OAAO,CAAC,CAAC,CAAC,EAAE;IACrGH,IAAI,CAACW,IAAI,CAACiB,IAAI,CAAC;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,YAAYA,CAACzC,SAAS,EAAExC,UAAU,EAAE;EACzC,IAAI0B,KAAK,GAAGwC,aAAa;EACzB,IAAIlE,UAAU,CAAC0B,KAAK,EAAE;IAClBA,KAAK,GAAG1B,UAAU,CAAC0B,KAAK;EAC5B,CAAC,MACI,IAAI1B,UAAU,CAAC4B,KAAK,EAAE;IACvB,IAAI5B,UAAU,CAACY,IAAI,KAAK,OAAO,IAAIZ,UAAU,CAACY,IAAI,KAAK,QAAQ,EAAE;MAC7Dc,KAAK,GAAGwD,IAAI,CAACC,KAAK,CAAC,CAACnF,UAAU,CAAC4B,KAAK,CAACyB,OAAO,CAAC,CAAC,GAAGb,SAAS,CAACa,OAAO,CAAC,CAAC,IAAIjE,UAAU,CAAC,GAAG,CAAC;IAC3F,CAAC,MACI,IAAIY,UAAU,CAACY,IAAI,KAAK,SAAS,IAAIZ,UAAU,CAACY,IAAI,KAAK,QAAQ,EAAE;MACpEc,KAAK,GAAGwD,IAAI,CAACC,KAAK,CAAC,CAAEnF,UAAU,CAAC4B,KAAK,CAACI,QAAQ,CAAC,CAAC,GAAG,EAAE,GAAGhC,UAAU,CAAC4B,KAAK,CAACK,WAAW,CAAC,CAAC,IACjFO,SAAS,CAACR,QAAQ,CAAC,CAAC,GAAG,EAAE,GAAGQ,SAAS,CAACP,WAAW,CAAC,CAAC,CAAC,IAAIjC,UAAU,CAACW,QAAQ,CAAC,IAC5EX,UAAU,CAACgB,GAAG,CAACI,MAAM,GAAG,CAAC,GAAI8D,IAAI,CAACC,KAAK,CAAC,CAACnF,UAAU,CAAC4B,KAAK,CAACyB,OAAO,CAAC,CAAC,GAAGb,SAAS,CAACa,OAAO,CAAC,CAAC,IAAIjE,UAAU,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC;MACvH,IAAIY,UAAU,CAACY,IAAI,KAAK,QAAQ,EAAE;QAC9Bc,KAAK,GAAG1B,UAAU,CAACwB,KAAK,CAACJ,MAAM,GAAG,CAAC,GAAIM,KAAK,GAAG1B,UAAU,CAACwB,KAAK,CAACJ,MAAM,GAAIM,KAAK;MACnF;IACJ;EACJ;EACA,OAAOA,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6C,SAASA,CAAC/B,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EACrD,IAAI6B,QAAQ,GAAG,IAAIuB,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;EAC5C,IAAI1C,QAAQ,GAAGX,UAAU,CAACW,QAAQ;EAClC,IAAI0E,aAAa,GAAGJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;EACvD,IAAIsF,KAAK;EACT,IAAIC,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC,OAAOwE,YAAY,CAAC3D,QAAQ,EAAEuD,OAAO,CAAC,EAAE;IACpCE,KAAK,GAAG,IAAI;IACZA,KAAK,GAAGG,aAAa,CAAC5D,QAAQ,EAAE7B,UAAU,CAAC;IAC3C,IAAIsF,KAAK,KAAKC,YAAY,CAACP,OAAO,CAACZ,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,IAAIH,YAAY,CAACnE,MAAM,KAAK,CAAC,CAAC,EAAE;MAChGyD,kBAAkB,CAAC3B,IAAI,EAAErB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;MAC5C,IAAIgC,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;QAChF;MACJ;IACJ;IACAxD,QAAQ,CAACoC,OAAO,CAACpC,QAAQ,CAACE,OAAO,CAAC,CAAC,GAAGpB,QAAQ,CAAC;IAC/C,IAAIkB,QAAQ,CAAC8D,QAAQ,CAAC,CAAC,KAAKnD,SAAS,CAACmD,QAAQ,CAAC,CAAC,EAAE;MAC9C9D,QAAQ,CAACiC,QAAQ,CAACtB,SAAS,CAACmD,QAAQ,CAAC,CAAC,CAAC;IAC3C;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASnB,UAAUA,CAAChC,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EACtD,IAAI6B,QAAQ,GAAG,IAAIuB,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;EAC5C,IAAI,CAACrD,UAAU,CAACgB,GAAG,CAACI,MAAM,EAAE;IACxBpB,UAAU,CAACgB,GAAG,CAAC6C,IAAI,CAACO,QAAQ,CAAC5B,SAAS,CAACkD,MAAM,CAAC,CAAC,CAAC,CAAC;EACrD;EACA,IAAI/E,QAAQ,GAAGX,UAAU,CAACW,QAAQ;EAClC,IAAI4E,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC,IAAIqE,aAAa,GAAGJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;EACvD,IAAI4F,SAAS,GAAG,IAAI;EACpB,IAAIC,SAAS;EACb,IAAIC,cAAc,GAAG,EAAE;EACvB,IAAIP,YAAY,CAACnE,MAAM,GAAG,CAAC,EAAE;IACzB,IAAIpC,iBAAiB,CAACgB,UAAU,CAAC+F,IAAI,CAAC,IAAI/F,UAAU,CAAC+F,IAAI,KAAK,EAAE,EAAE;MAC9D/F,UAAU,CAAC+F,IAAI,GAAGC,QAAQ,CAAC,CAAC,CAAC;IACjC;IACAH,SAAS,GAAGzB,QAAQ,CAACY,OAAO,CAAChF,UAAU,CAAC+F,IAAI,CAAC;IAC7C,OAAOP,YAAY,CAAC3D,QAAQ,EAAEuD,OAAO,CAAC,EAAE;MACpC,IAAIa,aAAa,GAAG7B,QAAQ,CAACY,OAAO,CAACZ,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGG,SAAS;MAC7EI,aAAa,GAAGA,aAAa,KAAK,CAAC,CAAC,GAAG,CAAC,GAAGA,aAAa;MACxD,IAAIC,aAAa,GAAG7G,OAAO,CAACwC,QAAQ,EAAE,CAACoE,aAAa,CAAC;MACrD,IAAIE,WAAW,GAAG9G,OAAO,CAAC6G,aAAa,EAAE,CAAC,CAAC;MAC3C,IAAIE,eAAe,GAAG,IAAIhD,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;MAClD8C,WAAW,GAAG7G,SAAS,CAAC6G,WAAW,CAAC;MACpCC,eAAe,GAAG9G,SAAS,CAAC8G,eAAe,CAAC;MAC5C,OAAOD,WAAW,IAAIC,eAAe,EAAE;QACnC,IAAIb,YAAY,CAACP,OAAO,CAACZ,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;UACxDI,cAAc,CAACjC,IAAI,CAAC,CAAChC,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC,CAAC;QAC7C;QACA,IAAIgC,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;UAChF;QACJ;QACAxD,QAAQ,CAACoC,OAAO,CAACpC,QAAQ,CAACE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;QACxC,IAAIF,QAAQ,CAAC8D,QAAQ,CAAC,CAAC,KAAKnD,SAAS,CAACmD,QAAQ,CAAC,CAAC,EAAE;UAC9C9D,QAAQ,CAACiC,QAAQ,CAACtB,SAAS,CAACmD,QAAQ,CAAC,CAAC,CAAC;QAC3C;QACAS,eAAe,GAAG,IAAIhD,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;QAC9C+C,eAAe,GAAG9G,SAAS,CAAC8G,eAAe,CAAC;MAChD;MACAvE,QAAQ,CAACoC,OAAO,CAACpC,QAAQ,CAACE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;MACxC,IAAIsD,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;QAChF;MACJ;MACAxD,QAAQ,CAACoC,OAAO,CAAEpC,QAAQ,CAACE,OAAO,CAAC,CAAC,GAAI,CAAC,GAAI,CAACpB,QAAQ,GAAG,CAAC,IAAI,CAAE,CAAC;MACjE0F,oBAAoB,CAACP,cAAc,EAAEF,SAAS,EAAEpD,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;MACrF8F,cAAc,GAAG,EAAE;IACvB;EACJ,CAAC,MACI;IACDjE,QAAQ,GAAGyE,mBAAmB,CAAC9D,SAAS,EAAExC,UAAU,CAACgB,GAAG,CAAC;IACzD,OAAOwE,YAAY,CAAC3D,QAAQ,EAAEuD,OAAO,CAAC,EAAE;MACpCQ,SAAS,GAAGH,aAAa,CAAC5D,QAAQ,EAAE7B,UAAU,CAAC;MAC/C,IAAI4F,SAAS,IAAKL,YAAY,CAACP,OAAO,CAACZ,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAE,EAAE;QACvEb,kBAAkB,CAAC3B,IAAI,EAAErB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;MAChD;MACA,IAAIgC,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;QAChF;MACJ;MACAxD,QAAQ,CAACoC,OAAO,CAACpC,QAAQ,CAACE,OAAO,CAAC,CAAC,GAAIpB,QAAQ,GAAG,CAAE,CAAC;IACzD;IACA0F,oBAAoB,CAACP,cAAc,EAAEF,SAAS,EAAEpD,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IACrF8F,cAAc,GAAG,EAAE;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrB,WAAWA,CAACjC,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EACvD;EACA,IAAI,CAACA,UAAU,CAACwB,KAAK,CAACJ,MAAM,IAAI,CAACpB,UAAU,CAACgB,GAAG,CAACI,MAAM,IAAI,CAACpB,UAAU,CAACmC,QAAQ,CAACf,MAAM,EAAE;IACnFpB,UAAU,CAACmC,QAAQ,CAAC0B,IAAI,CAACrB,SAAS,CAACT,OAAO,CAAC,CAAC,CAAC;IAC7C,IAAI/B,UAAU,CAACY,IAAI,KAAK,QAAQ,EAAE;MAC9BZ,UAAU,CAACwB,KAAK,CAACqC,IAAI,CAACrB,SAAS,CAACR,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC;IACnD;EACJ,CAAC,MACI,IAAIhC,UAAU,CAACwB,KAAK,CAACJ,MAAM,GAAG,CAAC,IAAI,CAACpB,UAAU,CAACgB,GAAG,CAACI,MAAM,IAAI,CAACpB,UAAU,CAACmC,QAAQ,CAACf,MAAM,EAAE;IAC3FpB,UAAU,CAACmC,QAAQ,CAAC0B,IAAI,CAACrB,SAAS,CAACT,OAAO,CAAC,CAAC,CAAC;EACjD;EACA,IAAIwE,QAAQ,GAAGC,uBAAuB,CAACxG,UAAU,CAAC;EAClD,QAAQuG,QAAQ;IACZ,KAAK,KAAK;MACN,QAAQvG,UAAU,CAACY,IAAI;QACnB,KAAK,SAAS;UACV6F,iCAAiC,CAACjE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;UACvE;QACJ,KAAK,QAAQ;UACT0G,qBAAqB,CAAClE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;UAC3D;MACR;MACA;IACJ,KAAK,MAAM;IACX,KAAK,MAAM;MACP,QAAQA,UAAU,CAACY,IAAI;QACnB,KAAK,SAAS;UACV+F,kCAAkC,CAACnE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;UACxE;QACJ,KAAK,QAAQ;UACT4G,sBAAsB,CAACpE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;UAC5D;MACR;MACA;EACR;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0E,UAAUA,CAAClC,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EACtD,IAAI6G,SAAS,GAAGC,eAAe,CAAC9G,UAAU,CAAC;EAC3C,QAAQ6G,SAAS;IACb,KAAK,OAAO;MACRpC,WAAW,CAACjC,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;MACjD;IACJ,KAAK,QAAQ;MACT+G,aAAa,CAACvE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;MACnD;IACJ,KAAK,SAAS;MACVgH,cAAc,CAACxE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;MACpD;EACR;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+G,aAAaA,CAACvE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EACzD,IAAIiH,MAAM,GAAGjE,YAAY,CAACkE,eAAe,CAAC1E,SAAS,EAAE,CAAC,CAAC;EACvD,IAAIX,QAAQ;EACZ,IAAIwD,aAAa,GAAGJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;EACvD,IAAIsF,KAAK;EACT,IAAI6B,QAAQ;EACZ,IAAIC,aAAa;EACjB,IAAIC,OAAO,GAAGrH,UAAU,CAACsH,MAAM;EAC/B,IAAIA,MAAM;EACV,IAAIC,OAAO;EACX,IAAIC,OAAO;EACX,IAAI1B,cAAc,GAAG,EAAE;EACvB,IAAIP,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC,OAAOwE,YAAY,CAACyB,MAAM,EAAE7B,OAAO,CAAC,EAAE;IAClC+B,QAAQ,GAAGnB,QAAQ,CAAChB,OAAO,CAACZ,QAAQ,CAAC6C,MAAM,CAACvB,MAAM,CAAC,CAAC,CAAC,CAAC;IACtD0B,aAAa,GAAI,CAAC,GAAGD,QAAQ,GAAI,CAAC;IAClC,KAAK,IAAIjG,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGmG,OAAO,CAACjG,MAAM,EAAEF,KAAK,EAAE,EAAE;MACjDoG,MAAM,GAAGD,OAAO,CAAChD,QAAQ,CAACnD,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;MAChD6F,MAAM,GAAIA,MAAM,GAAG,CAAC,GAAIA,MAAM,GAAG,EAAE,GAAGA,MAAM,GAAG,CAAC;MAChDC,OAAO,GAAID,MAAM,KAAK,CAAC,GAAIF,aAAa,GAAGA,aAAa,GAAI,CAACE,MAAM,GAAG,CAAC,IAAI,CAAE;MAC7EE,OAAO,GAAIF,MAAM,KAAK,CAAC,GAAIF,aAAa,GAAG,CAAC,GAAGA,aAAa,GAAI,CAACE,MAAM,GAAG,CAAC,IAAI,CAAE;MACjF,OAAOE,OAAO,GAAGD,OAAO,EAAE;QACtB1F,QAAQ,GAAG,IAAIuB,IAAI,CAAC6D,MAAM,CAAC5D,OAAO,CAAC,CAAC,GAAIjE,UAAU,GAAGoI,OAAQ,CAAC;QAC9D,IAAIjC,YAAY,CAACnE,MAAM,KAAK,CAAC,IAAImE,YAAY,CAACP,OAAO,CAACZ,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;UACrF,IAAI1G,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;YAC3CoF,oBAAoB,CAACnC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE6B,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;UACzF,CAAC,MACI;YACDyC,cAAc,CAACjC,IAAI,CAAC,CAAChC,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC,CAAC;UAC7C;QACJ;QACAmE,OAAO,EAAE;MACb;IACJ;IACA,IAAI,CAACxI,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;MAC5CqF,iCAAiC,CAAC5B,cAAc,EAAER,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IAClG;IACA,IAAIqF,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;MAChF;IACJ;IACA4B,MAAM,GAAGjE,YAAY,CAACkE,eAAe,CAACrF,QAAQ,EAAE7B,UAAU,CAACW,QAAQ,CAAC;IACpEmF,cAAc,GAAG,EAAE;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkB,cAAcA,CAACxE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EAC1D,IAAIiH,MAAM,GAAGjE,YAAY,CAACkE,eAAe,CAAC1E,SAAS,EAAE,CAAC,CAAC;EACvD,IAAIX,QAAQ;EACZ,IAAIwD,aAAa,GAAGJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;EACvD,IAAIsF,KAAK;EACT,IAAIqC,cAAc,GAAG,EAAE;EACvB,IAAI7C,IAAI;EACR,IAAIS,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC,OAAOwE,YAAY,CAACyB,MAAM,EAAE7B,OAAO,CAAC,EAAE;IAClC,KAAK,IAAIlE,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGlB,UAAU,CAAC4H,OAAO,CAACxG,MAAM,EAAEF,KAAK,EAAE,EAAE;MAC5D4D,IAAI,GAAG9E,UAAU,CAAC4H,OAAO,CAACvD,QAAQ,CAACnD,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;MACzDI,QAAQ,GAAG,IAAIuB,IAAI,CAAC6D,MAAM,CAAC5D,OAAO,CAAC,CAAC,CAAC;MACrC,IAAI,CAACyB,IAAI,KAAK9B,YAAY,CAAC6E,oBAAoB,CAAC,CAAC,IAAI/C,IAAI,KAAK,CAAC9B,YAAY,CAAC6E,oBAAoB,CAAC,CAAC,KAC7F,CAAC7E,YAAY,CAAC8E,UAAU,CAAC9E,YAAY,CAACf,WAAW,CAACJ,QAAQ,CAAC,EAAE,CAAC,CAAE,EAAE;QACnEA,QAAQ,CAACoC,OAAO,CAACpC,QAAQ,CAACE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;QACxC;MACJ;MACAF,QAAQ,CAACoC,OAAO,CAACpC,QAAQ,CAACE,OAAO,CAAC,CAAC,IAAK+C,IAAI,GAAG,CAAC,GAC5C9B,YAAY,CAAC+E,gBAAgB,CAAClG,QAAQ,EAAE,CAAC,CAAC,GAAG,CAAC,GAAGiD,IAAI,GAAGA,IAAI,CAAC,CAAC;MAClE,IAAIS,YAAY,CAACnE,MAAM,KAAK,CAAC,IAAImE,YAAY,CAACP,OAAO,CAACZ,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;QACrF,IAAI1F,UAAU,CAACqC,WAAW,IAAI,IAAI,EAAE;UAChCoF,oBAAoB,CAACnC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE6B,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;QACzF,CAAC,MACI;UACDsE,cAAc,CAAC9D,IAAI,CAAC,CAAChC,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC,CAAC;QAC7C;MACJ;IACJ;IACA,IAAI,CAACrE,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;MAC5CqF,iCAAiC,CAACC,cAAc,EAAErC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IAClG;IACA,IAAIqF,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;MAChF;IACJ;IACA4B,MAAM,GAAGjE,YAAY,CAACkE,eAAe,CAACrF,QAAQ,EAAE7B,UAAU,CAACW,QAAQ,CAAC;IACpEgH,cAAc,GAAG,EAAE;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,eAAeA,CAAC9G,UAAU,EAAE;EACjC,IAAIA,UAAU,CAAC4H,OAAO,CAACxG,MAAM,EAAE;IAC3B,OAAO,SAAS;EACpB,CAAC,MACI,IAAIpB,UAAU,CAACsH,MAAM,CAAClG,MAAM,EAAE;IAC/B,OAAO,QAAQ;EACnB;EACA,OAAO,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4G,0BAA0BA,CAACxF,SAAS,EAAExC,UAAU,EAAE;EACvD,IAAIiI,QAAQ,GAAG;IACXC,eAAe,EAAE,EAAE;IACnBhH,KAAK,EAAE,CAAC;IACRW,QAAQ,EAAE,IAAIuB,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;IACvC8E,QAAQ,EAAE,IAAI/E,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;IACvCgC,aAAa,EAAEJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;IAClDoI,SAAS,EAAE,CAAC;IACZT,cAAc,EAAE;EACpB,CAAC;EACD,IAAI3H,UAAU,CAACwB,KAAK,CAACJ,MAAM,EAAE;IACzB4B,YAAY,CAACqF,QAAQ,CAACJ,QAAQ,CAACpG,QAAQ,EAAE7B,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,EAAEyG,QAAQ,CAACpG,QAAQ,CAACE,OAAO,CAAC,CAAC,CAAC;EAC9F;EACA,OAAOkG,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASrB,sBAAsBA,CAACpE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EAClE,IAAIA,UAAU,CAACwB,KAAK,CAACJ,MAAM,EAAE;IACzBuF,kCAAkC,CAACnE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IACxE;EACJ;EACA,IAAIiI,QAAQ,GAAGD,0BAA0B,CAACxF,SAAS,EAAExC,UAAU,CAAC;EAChE,IAAIsI,gBAAgB;EACpBL,QAAQ,CAACpG,QAAQ,GAAGoG,QAAQ,CAACE,QAAQ,GAAGnF,YAAY,CAACuF,iBAAiB,CAACN,QAAQ,CAACpG,QAAQ,CAAC;EACzF,OAAO2D,YAAY,CAACyC,QAAQ,CAACpG,QAAQ,EAAEuD,OAAO,CAAC,EAAE;IAC7CkD,gBAAgB,GAAG,IAAIlF,IAAI,CAAC6E,QAAQ,CAACpG,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;IACxD,OAAOL,YAAY,CAACwF,UAAU,CAACF,gBAAgB,EAAEL,QAAQ,CAACpG,QAAQ,CAAC,IAC9DoG,QAAQ,CAAC5C,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKkE,QAAQ,CAAC5C,aAAc,EAAE;MACpG,IAAIrF,UAAU,CAACwB,KAAK,CAACJ,MAAM,KAAK,CAAC,IAAKpB,UAAU,CAACwB,KAAK,CAACJ,MAAM,GAAG,CAAC,IAC1D,CAAC4B,YAAY,CAACyF,UAAU,CAACR,QAAQ,CAACpG,QAAQ,EAAE7B,UAAU,CAACwB,KAAK,CAAE,EAAE;QACnEkH,kCAAkC,CAAC1I,UAAU,EAAEiI,QAAQ,EAAE7C,OAAO,EAAE,KAAK,CAAC;QACxE6C,QAAQ,CAACU,SAAS,GAAG,IAAIvF,IAAI,CAAC6E,QAAQ,CAACpG,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;QAC1D4E,QAAQ,CAACG,SAAS,GAAGQ,gBAAgB,CAACX,QAAQ,CAACpG,QAAQ,EAAE7B,UAAU,EAAEiI,QAAQ,CAACG,SAAS,EAAEH,QAAQ,CAACU,SAAS,CAAC;MAChH,CAAC,MACI;QACD3F,YAAY,CAAC6F,YAAY,CAACZ,QAAQ,CAACpG,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;QAClDoG,QAAQ,CAACpG,QAAQ,GAAGyE,mBAAmB,CAAC2B,QAAQ,CAACpG,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;QAC1E;MACJ;IACJ;IACAiH,QAAQ,CAACpG,QAAQ,CAACiH,WAAW,CAACR,gBAAgB,CAACrG,WAAW,CAAC,CAAC,EAAEqG,gBAAgB,CAACtG,QAAQ,CAAC,CAAC,EAAEsG,gBAAgB,CAACvG,OAAO,CAAC,CAAC,CAAC;IACtHsE,oBAAoB,CAAC4B,QAAQ,CAACN,cAAc,EAAEM,QAAQ,CAAC3C,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IACnG,IAAIgD,YAAY,CAAC+F,WAAW,CAACd,QAAQ,CAACpG,QAAQ,CAAC,EAAE;MAC7CmB,YAAY,CAAC6F,YAAY,CAACZ,QAAQ,CAACpG,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;MAClDoG,QAAQ,CAACpG,QAAQ,GAAGyE,mBAAmB,CAAC2B,QAAQ,CAACpG,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;IAC9E;IACA,IAAIiH,QAAQ,CAAC5C,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKkE,QAAQ,CAAC5C,aAAa,EAAE;MAClG;IACJ;IACA4C,QAAQ,CAACpG,QAAQ,CAACiH,WAAW,CAACb,QAAQ,CAACpG,QAAQ,CAACI,WAAW,CAAC,CAAC,GAAGjC,UAAU,CAACW,QAAQ,GAAG,CAAC,CAAC;IACxFsH,QAAQ,CAACpG,QAAQ,GAAGyE,mBAAmB,CAAC2B,QAAQ,CAACpG,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;IAC1EiH,QAAQ,CAACG,SAAS,GAAGQ,gBAAgB,CAACX,QAAQ,CAACpG,QAAQ,EAAE7B,UAAU,EAAEiI,QAAQ,CAACG,SAAS,EAAEH,QAAQ,CAACU,SAAS,CAAC;IAC5GV,QAAQ,CAACN,cAAc,GAAG,EAAE;EAChC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAShB,kCAAkCA,CAACnE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EAC9E,IAAIiI,QAAQ,GAAGD,0BAA0B,CAACxF,SAAS,EAAExC,UAAU,CAAC;EAChEiI,QAAQ,CAACpG,QAAQ,GAAGoG,QAAQ,CAACE,QAAQ,GAAGnF,YAAY,CAACuF,iBAAiB,CAACN,QAAQ,CAACpG,QAAQ,CAAC;EACzF,IAAI,CAAE7B,UAAU,CAACY,IAAI,KAAK,SAAS,IAAIZ,UAAU,CAACW,QAAQ,KAAK,EAAE,IAAMX,UAAU,CAACY,IAAI,KAAK,QAAS,KAChGoC,YAAY,CAACgG,iBAAiB,CAACxG,SAAS,CAAC,GAAGxC,UAAU,CAACmC,QAAQ,CAAC,CAAC,CAAC,EAAE;IACpE;EACJ;EACA,OAAOqD,YAAY,CAACyC,QAAQ,CAACpG,QAAQ,EAAEuD,OAAO,CAAC,EAAE;IAC7C6C,QAAQ,CAACU,SAAS,GAAG,IAAIvF,IAAI,CAAC6E,QAAQ,CAACpG,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;IAC1DqF,kCAAkC,CAAC1I,UAAU,EAAEiI,QAAQ,EAAE7C,OAAO,EAAE,IAAI,EAAE5C,SAAS,EAAEU,IAAI,CAAC;IACxF,IAAI,CAAClE,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;MAC5CqF,iCAAiC,CAACO,QAAQ,CAACN,cAAc,EAAEM,QAAQ,CAAC3C,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IACpH;IACA,IAAIiI,QAAQ,CAAC5C,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKkE,QAAQ,CAAC5C,aAAa,EAAE;MAClG;IACJ;IACA4C,QAAQ,CAACG,SAAS,GAAGQ,gBAAgB,CAACX,QAAQ,CAACpG,QAAQ,EAAE7B,UAAU,EAAEiI,QAAQ,CAACG,SAAS,EAAEH,QAAQ,CAACU,SAAS,CAAC;IAC5GV,QAAQ,CAACN,cAAc,GAAG,EAAE;EAChC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASe,kCAAkCA,CAAC1I,UAAU,EAAEiJ,gBAAgB,EAAE7D,OAAO,EAAE8D,SAAS,EAAE1G,SAAS,EAAEU,IAAI,EAAE;EAC3G,KAAK,IAAIhC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGlB,UAAU,CAACmC,QAAQ,CAACf,MAAM,EAAEF,KAAK,EAAE,EAAE;IAC7D+H,gBAAgB,CAACnE,IAAI,GAAG9E,UAAU,CAACmC,QAAQ,CAACkC,QAAQ,CAACnD,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAC3EwH,gBAAgB,CAACpH,QAAQ,GAAGmB,YAAY,CAACuF,iBAAiB,CAACU,gBAAgB,CAACpH,QAAQ,CAAC;IACrF,IAAI0F,OAAO,GAAGvE,YAAY,CAACgG,iBAAiB,CAACC,gBAAgB,CAACpH,QAAQ,CAAC;IACvEoH,gBAAgB,CAACnE,IAAI,GAAGmE,gBAAgB,CAACnE,IAAI,GAAG,CAAC,GAAGmE,gBAAgB,CAACnE,IAAI,GAAIyC,OAAO,GAAG0B,gBAAgB,CAACnE,IAAI,GAAG,CAAE;IACjH,IAAIqE,kBAAkB,CAACF,gBAAgB,CAACpH,QAAQ,EAAEoH,gBAAgB,CAACnE,IAAI,EAAEmE,gBAAgB,CAACd,QAAQ,CAAC,IAC3Fc,gBAAgB,CAACnE,IAAI,GAAG,CAAE,EAAE;MAChC9B,YAAY,CAACiB,OAAO,CAACgF,gBAAgB,CAACpH,QAAQ,EAAEoH,gBAAgB,CAACnE,IAAI,CAAC;MACtE,IAAIM,OAAO,IAAI6D,gBAAgB,CAACpH,QAAQ,GAAGuD,OAAO,EAAE;QAChD;MACJ;MACA,IAAIpF,UAAU,CAACgB,GAAG,CAACI,MAAM,KAAK,CAAC,IAAIpB,UAAU,CAACgB,GAAG,CAACgE,OAAO,CAACZ,QAAQ,CAAC6E,gBAAgB,CAACpH,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;QAC1G,IAAIwD,SAAS,IAAIlK,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,IAAK4G,gBAAgB,CAAC5D,aAAa,IACrFnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,GAAIkF,gBAAgB,CAAC5D,aAAc,EAAE;UACnFoC,oBAAoB,CAACwB,gBAAgB,CAAC3D,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEiJ,gBAAgB,CAACpH,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;QAC3H,CAAC,MACI;UACD4F,gBAAgB,CAACtB,cAAc,CAAC9D,IAAI,CAAC,CAACoF,gBAAgB,CAACpH,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC,CAAC;QAC/E;MACJ;IACJ;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuF,gBAAgBA,CAAC/G,QAAQ,EAAE7B,UAAU,EAAEoI,SAAS,EAAEO,SAAS,EAAEhI,QAAQ,EAAE;EAC5E,IAAIgI,SAAS,KAAK,KAAK,CAAC,EAAE;IAAEA,SAAS,GAAG,IAAI;EAAE;EAC9C,IAAIS,SAAS,GAAGT,SAAS,GAAGA,SAAS,CAAC3G,QAAQ,CAAC,CAAC,GAAG,CAAC;EACpD,IAAIQ,SAAS,GAAGQ,YAAY,CAACuF,iBAAiB,CAAC1G,QAAQ,CAAC;EACxDlB,QAAQ,GAAG3B,iBAAiB,CAAC2B,QAAQ,CAAC,GAAGX,UAAU,CAACW,QAAQ,GAAGA,QAAQ;EACvEkB,QAAQ,CAACiH,WAAW,CAACtG,SAAS,CAACP,WAAW,CAAC,CAAC,CAAC;EAC7CJ,QAAQ,CAACwG,QAAQ,CAAC7F,SAAS,CAACR,QAAQ,CAAC,CAAC,CAAC;EACvCH,QAAQ,CAACoC,OAAO,CAACzB,SAAS,CAACT,OAAO,CAAC,CAAC,CAAC;EACrC,IAAI/B,UAAU,CAACwB,KAAK,CAACJ,MAAM,EAAE;IACzBgH,SAAS,EAAE;IACXA,SAAS,GAAGA,SAAS,GAAGpI,UAAU,CAACwB,KAAK,CAACJ,MAAM;IAC/C4B,YAAY,CAACqF,QAAQ,CAACxG,QAAQ,EAAE7B,UAAU,CAACwB,KAAK,CAAC6C,QAAQ,CAAC+D,SAAS,CAAC3G,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC;IACxF,IAAI2G,SAAS,KAAK,CAAC,EAAE;MACjBpF,YAAY,CAACqG,QAAQ,CAACxH,QAAQ,EAAElB,QAAQ,EAAEX,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,CAAC;IAClE;EACJ,CAAC,MACI;IACD,IAAImH,SAAS,IAAKA,SAAS,CAAC1G,WAAW,CAAC,CAAC,GAAGJ,QAAQ,CAACI,WAAW,CAAC,CAAE,EAAE;MACjEmH,SAAS,GAAGvH,QAAQ,CAACG,QAAQ,CAAC,CAAC,GAAG,CAAC;IACvC;IACAgB,YAAY,CAAC6F,YAAY,CAAChH,QAAQ,EAAElB,QAAQ,EAAE,CAAC,EAAEyI,SAAS,EAAET,SAAS,CAAC;EAC1E;EACA,OAAOP,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkB,kBAAkBA,CAAC9G,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EAC9D,IAAIuF,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC,IAAIa,QAAQ,GAAG,IAAIuB,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;EAC5CxB,QAAQ,GAAGmB,YAAY,CAACuF,iBAAiB,CAAC1G,QAAQ,CAAC;EACnD,IAAIqG,eAAe,GAAG,EAAE;EACxB,IAAIP,cAAc,GAAG,EAAE;EACvB,IAAI4B,KAAK,GAAG,EAAE;EACd,IAAIrI,KAAK;EACT,IAAIoE,KAAK;EACT,IAAID,aAAa,GAAGJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;EACvD,IAAIoI,SAAS,GAAG,CAAC;EACjB,IAAIO,SAAS;EACb,IAAI3I,UAAU,CAACwB,KAAK,CAACJ,MAAM,EAAE;IACzB4B,YAAY,CAACqF,QAAQ,CAACxG,QAAQ,EAAE7B,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EAC3D;EACAK,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;EACxD,OAAOwE,YAAY,CAAC3D,QAAQ,EAAEuD,OAAO,CAAC,IAC9BC,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,GAAIsB,aAAc,EAAE;IACpF,IAAIiD,gBAAgB,GAAG,IAAIlF,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;IACnD,IAAImG,cAAc,GAAGjE,YAAY,CAACkE,GAAG,CAAC,UAAUC,IAAI,EAAE;MAAE,OAAOC,SAAS,CAACC,IAAI,CAACF,IAAI,CAAC;IAAE,CAAC,CAAC;IACvF,IAAIF,cAAc,CAACxE,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;MACnC,KAAK,IAAI6E,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAItE,YAAY,CAACnE,MAAM,GAAG,CAAC,EAAEyI,CAAC,EAAE,EAAE;QAC/C,IAAIC,iBAAiB,GAAGvE,YAAY,CAAClB,QAAQ,CAACwF,CAAC,CAACpI,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAACsI,KAAK,CAACC,oBAAoB,CAAC;QAC5F,IAAIC,QAAQ,GAAG5F,QAAQ,CAACyF,iBAAiB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACjDjI,QAAQ,GAAG,IAAIuB,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;QACvCxB,QAAQ,GAAGmB,YAAY,CAACuF,iBAAiB,CAAC1G,QAAQ,CAAC;QACnDA,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE0D,YAAY,CAAC;QACtD+C,gBAAgB,CAACQ,WAAW,CAACjH,QAAQ,CAACI,WAAW,CAAC,CAAC,EAAEJ,QAAQ,CAACG,QAAQ,CAAC,CAAC,EAAEH,QAAQ,CAACE,OAAO,CAAC,CAAC,CAAC;QAC7F,OAAOiB,YAAY,CAACwF,UAAU,CAACF,gBAAgB,EAAEzG,QAAQ,CAAC,IAAImB,YAAY,CAACkH,WAAW,CAAC5B,gBAAgB,EAAEzG,QAAQ,CAAC,EAAE;UAChH,IAAIiI,iBAAiB,CAACA,iBAAiB,CAAC1I,MAAM,GAAG,CAAC,CAAC,KAAKgD,QAAQ,CAACkE,gBAAgB,CAAC5C,MAAM,CAAC,CAAC,CAAC,EAAE;YACzFwC,eAAe,CAACrE,IAAI,CAAC,CAACyE,gBAAgB,CAACjF,OAAO,CAAC,CAAC,CAAC,CAAC;UACtD;UACAiF,gBAAgB,CAACrE,OAAO,CAACqE,gBAAgB,CAACvG,OAAO,CAAC,CAAC,GAAI,CAAE,CAAC;QAC9D;QACAuG,gBAAgB,CAACrE,OAAO,CAACqE,gBAAgB,CAACvG,OAAO,CAAC,CAAC,GAAI,CAAE,CAAC;QAC1D,IAAI+H,iBAAiB,CAAC,CAAC,CAAC,CAAC9E,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;UACxC9D,KAAK,GAAGgH,eAAe,CAAC9G,MAAM,GAAI,CAAC,CAAC,GAAG6I,QAAS;QACpD,CAAC,MACI;UACD/I,KAAK,GAAG+I,QAAQ,GAAG,CAAC;QACxB;QACA/I,KAAK,GAAGiJ,KAAK,CAACjJ,KAAK,CAAC,GAAG,CAAC,GAAGA,KAAK;QAChC,IAAIgH,eAAe,CAAC9G,MAAM,GAAG,CAAC,EAAE;UAC5B,IAAIpC,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;YAC3CqF,iCAAiC,CAACQ,eAAe,EAAE5C,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEkB,KAAK,CAAC;UAC1G,CAAC,MACI;YACDyG,cAAc,GAAG,CAAEyC,2BAA2B,CAAClC,eAAe,EAAEhH,KAAK,EAAEqI,KAAK,CAAC,CAAE;UACnF;QACJ;QACA,IAAIlE,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;UAChF;QACJ;QACA6C,eAAe,GAAG,EAAE;MACxB;MACA,IAAI,CAAClJ,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;QAC5CgI,mCAAmC,CAAC1C,cAAc,EAAErC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;QAChGuJ,KAAK,GAAG,EAAE;MACd;MACAnB,SAAS,GAAGQ,gBAAgB,CAAC/G,QAAQ,EAAE7B,UAAU,EAAEoI,SAAS,EAAEO,SAAS,CAAC;MACxE9G,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;MACxDkH,eAAe,GAAG,EAAE;IACxB,CAAC,MACI;MACD,IAAIpC,cAAc,GAAG,EAAE;MACvB,IAAIwE,YAAY,GAAGC,eAAe,CAAChF,YAAY,CAAC;MAChD+C,gBAAgB,CAACQ,WAAW,CAACjH,QAAQ,CAACI,WAAW,CAAC,CAAC,EAAEJ,QAAQ,CAACG,QAAQ,CAAC,CAAC,EAAEH,QAAQ,CAACE,OAAO,CAAC,CAAC,CAAC;MAC7F,IAAIyI,WAAW,GAAG,IAAIpH,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;MAC9CsF,SAAS,GAAG,IAAIvF,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;MACxC,OAAOL,YAAY,CAACkH,WAAW,CAACM,WAAW,EAAE3I,QAAQ,CAAC,EAAE;QACpDiE,cAAc,CAACjC,IAAI,CAAChC,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;QACvC,IAAIkC,YAAY,CAACP,OAAO,CAACZ,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;UACxDwC,eAAe,CAACrE,IAAI,CAACiC,cAAc,CAAC;UACpCA,cAAc,GAAG,EAAE;QACvB;QACAjE,QAAQ,CAACoC,OAAO,CAACpC,QAAQ,CAACE,OAAO,CAAC,CAAC,GAC7BuI,YAAY,CAAClG,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;MACpD;MACAxE,KAAK,GAAKlB,UAAU,CAACqC,WAAW,GAAG,CAAC,GAAK6F,eAAe,CAAC9G,MAAM,GAAGpB,UAAU,CAACqC,WAAW,GAAIrC,UAAU,CAACqC,WAAW,GAAG,CAAE;MACvH,IAAIrD,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;QAC3CnB,KAAK,GAAG,CAAC;QACT,IAAIuJ,KAAK,GAAG,EAAE;QACd,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGxC,eAAe,CAAC9G,MAAM,EAAEsJ,IAAI,EAAE,EAAE;UACtD,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGzC,eAAe,CAAC7D,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAACL,MAAM,EAAEuJ,GAAG,EAAE,EAAE;YAClFF,KAAK,CAAC5G,IAAI,CAACqE,eAAe,CAAC7D,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC4C,QAAQ,CAACsG,GAAG,CAAClJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;UAC5F;QACJ;QACAyG,eAAe,GAAG,CAACuC,KAAK,CAAC;MAC7B;MACA,IAAIvC,eAAe,CAAC9G,MAAM,GAAG,CAAC,EAAE;QAC5BsG,iCAAiC,CAACQ,eAAe,EAAE5C,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEkB,KAAK,CAAC;MAC1G;MACA,IAAImE,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;QAChF;MACJ;MACA+C,SAAS,GAAGQ,gBAAgB,CAAC/G,QAAQ,EAAE7B,UAAU,EAAEoI,SAAS,EAAEO,SAAS,CAAC;MACxE9G,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;MACxDkH,eAAe,GAAG,EAAE;IACxB;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASzB,iCAAiCA,CAACjE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EAC7E,IAAIuF,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC;EACA,IAAIuE,YAAY,CAACnE,MAAM,GAAG,CAAC,EAAE;IACzBkI,kBAAkB,CAAC9G,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IACxD;EACJ;EACA,IAAI6B,QAAQ,GAAG,IAAIuB,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;EAC5C,IAAIgC,aAAa,GAAGJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;EACvD,IAAIkI,eAAe,GAAG,EAAE;EACxB,IAAIS,SAAS;EACb,IAAIP,SAAS,GAAG,CAAC;EACjBvG,QAAQ,GAAGmB,YAAY,CAACuF,iBAAiB,CAAC1G,QAAQ,CAAC;EACnD,IAAI7B,UAAU,CAACwB,KAAK,CAACJ,MAAM,EAAE;IACzB4B,YAAY,CAACqF,QAAQ,CAACxG,QAAQ,EAAE7B,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EAC3D;EACAK,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;EACxD,OAAOwE,YAAY,CAAC3D,QAAQ,EAAEuD,OAAO,CAAC,IAAKC,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,GAAIsB,aAAc,EAAE;IACvHsD,SAAS,GAAG,IAAIvF,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;IACxC,IAAIiF,gBAAgB,GAAG,IAAIlF,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;IACnD,OAAOL,YAAY,CAACkH,WAAW,CAACrI,QAAQ,EAAEyG,gBAAgB,CAAC,EAAE;MACzDJ,eAAe,CAACrE,IAAI,CAAC,CAACyE,gBAAgB,CAACjF,OAAO,CAAC,CAAC,CAAC,CAAC;MAClDiF,gBAAgB,CAACrE,OAAO,CAACqE,gBAAgB,CAACvG,OAAO,CAAC,CAAC,GAAI,CAAE,CAAC;IAC9D;IACA;IACA6I,gCAAgC,CAAC1C,eAAe,EAAE1F,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IACvFoI,SAAS,GAAGQ,gBAAgB,CAAC/G,QAAQ,EAAE7B,UAAU,EAAEoI,SAAS,EAAEO,SAAS,CAAC;IACxE9G,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;IACxDkH,eAAe,GAAG,EAAE;EACxB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASxB,qBAAqBA,CAAClE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EACjE,IAAIuF,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC,IAAIwI,cAAc,GAAGjE,YAAY,CAACkE,GAAG,CAAC,UAAUC,IAAI,EAAE;IAAE,OAAOC,SAAS,CAACC,IAAI,CAACF,IAAI,CAAC;EAAE,CAAC,CAAC;EACvF;EACA,IAAInE,YAAY,CAACnE,MAAM,GAAG,CAAC,IAAIoI,cAAc,CAACxE,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;IAC9D6F,wCAAwC,CAACrI,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IAC9E;EACJ,CAAC,MACI,IAAIA,UAAU,CAACwB,KAAK,CAACJ,MAAM,IAAImE,YAAY,CAACnE,MAAM,KAAK,CAAC,IAAIoI,cAAc,CAACxE,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;IAChGyB,iCAAiC,CAACjE,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IACvE;EACJ;EACA,IAAI6B,QAAQ,GAAG,IAAIuB,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;EAC5C,IAAIiF,gBAAgB;EACpB,IAAIjD,aAAa,GAAGJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;EACvD,IAAIW,QAAQ,GAAGX,UAAU,CAACW,QAAQ;EAClC,IAAIuH,eAAe,GAAG,EAAE;EACxB,IAAIlI,UAAU,CAACwB,KAAK,CAACJ,MAAM,EAAE;IACzB4B,YAAY,CAACqF,QAAQ,CAACxG,QAAQ,EAAE7B,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,EAAEK,QAAQ,CAACE,OAAO,CAAC,CAAC,CAAC;EAC5E;EACA;EACA,IAAI/C,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,IAAIrC,UAAU,CAACwB,KAAK,CAACJ,MAAM,KAAK,CAAC,IAAIpB,UAAU,CAACsH,MAAM,CAAClG,MAAM,KAAK,CAAC,EAAE;IAC9GS,QAAQ,CAACiH,WAAW,CAACtG,SAAS,CAACP,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EACvD;EACAJ,QAAQ,GAAGmB,YAAY,CAACuF,iBAAiB,CAAC1G,QAAQ,CAAC;EACnDA,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;EACxD,OAAOwE,YAAY,CAAC3D,QAAQ,EAAEuD,OAAO,CAAC,EAAE;IACpCkD,gBAAgB,GAAG,IAAIlF,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;IAC/C,OAAOL,YAAY,CAACwF,UAAU,CAACF,gBAAgB,EAAEzG,QAAQ,CAAC,IACrDwD,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAc,EAAE;MAClFiD,gBAAgB,GAAG,IAAIlF,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;MAC/C,OAAOL,YAAY,CAACwF,UAAU,CAACF,gBAAgB,EAAEzG,QAAQ,CAAC,EAAE;QACxD,IAAI7B,UAAU,CAACwB,KAAK,CAACJ,MAAM,KAAK,CAAC,IAAKpB,UAAU,CAACwB,KAAK,CAACJ,MAAM,GAAG,CAAC,IAC1D,CAAC4B,YAAY,CAACyF,UAAU,CAAC5G,QAAQ,EAAE7B,UAAU,CAACwB,KAAK,CAAE,EAAE;UAC1D,IAAI+D,YAAY,CAACnE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI4B,YAAY,CAAC8H,YAAY,CAACxC,gBAAgB,EAAEzG,QAAQ,CAAC,EAAE;cACvDmB,YAAY,CAAC6F,YAAY,CAAChH,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;cACzCA,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;cACxD;YACJ;YACA,IAAIuE,YAAY,CAACP,OAAO,CAACZ,QAAQ,CAACkE,gBAAgB,CAAC5C,MAAM,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE;cAChEwC,eAAe,CAACrE,IAAI,CAAC,CAACyE,gBAAgB,CAACjF,OAAO,CAAC,CAAC,CAAC,CAAC;YACtD;YACAiF,gBAAgB,CAACrE,OAAO,CAACqE,gBAAgB,CAACvG,OAAO,CAAC,CAAC,GAAI,CAAE,CAAC;UAC9D,CAAC,MACI;YACD;YACA,IAAIuG,gBAAgB,CAACrG,WAAW,CAAC,CAAC,GAAGJ,QAAQ,CAACI,WAAW,CAAC,CAAC,EAAE;cACzDe,YAAY,CAAC6F,YAAY,CAAChH,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;cACzCA,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;cACxD;YACJ;YACA,IAAI+J,MAAM,GAAGC,YAAY,CAACzF,YAAY,CAAC,CAAC,CAAC,CAAC;YAC1C,IAAInB,QAAQ,CAACkE,gBAAgB,CAAC5C,MAAM,CAAC,CAAC,CAAC,KAAKqF,MAAM,IAC3C,IAAI3H,IAAI,CAACkF,gBAAgB,CAACrG,WAAW,CAAC,CAAC,EAAEqG,gBAAgB,CAACtG,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,GACrE,IAAIoB,IAAI,CAACZ,SAAS,CAACP,WAAW,CAAC,CAAC,CAAC,EAAE;cACzCiG,eAAe,CAACrE,IAAI,CAAC,CAACyE,gBAAgB,CAACjF,OAAO,CAAC,CAAC,CAAC,CAAC;YACtD;YACAiF,gBAAgB,CAACrE,OAAO,CAACqE,gBAAgB,CAACvG,OAAO,CAAC,CAAC,GAAI,CAAE,CAAC;UAC9D;QACJ,CAAC,MACI;UACDiB,YAAY,CAAC6F,YAAY,CAAChH,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;UACzCA,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;UACxD;QACJ;MACJ;IACJ;IACAa,QAAQ,CAACiH,WAAW,CAACR,gBAAgB,CAACrG,WAAW,CAAC,CAAC,EAAEqG,gBAAgB,CAACtG,QAAQ,CAAC,CAAC,EAAEsG,gBAAgB,CAACvG,OAAO,CAAC,CAAC,CAAC;IAC7G;IACA6I,gCAAgC,CAAC1C,eAAe,EAAE1F,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;IACvF,IAAIgD,YAAY,CAAC+F,WAAW,CAAClH,QAAQ,CAAC,EAAE;MACpCmB,YAAY,CAAC6F,YAAY,CAAChH,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;MACzCA,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;IAC5D;IACAa,QAAQ,CAACiH,WAAW,CAACjH,QAAQ,CAACI,WAAW,CAAC,CAAC,GAAGtB,QAAQ,GAAG,CAAC,CAAC;IAC3D,IAAI0E,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;MAChF;IACJ;IACAxD,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;IACxDkH,eAAe,GAAG,EAAE;EACxB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2C,wCAAwCA,CAACrI,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EACpF,IAAIuF,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC,IAAIqE,aAAa,GAAGJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;EACvD,IAAI6B,QAAQ,GAAG,IAAIuB,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;EAC5C,IAAI1C,QAAQ,GAAGX,UAAU,CAACW,QAAQ;EAClC,IAAIuH,eAAe,GAAG,EAAE;EACxB,IAAIP,cAAc,GAAG,EAAE;EACvB,IAAIzG,KAAK;EACT,IAAIoE,KAAK;EACT,IAAI8C,SAAS,GAAG,CAAC;EACjB,IAAIE,gBAAgB;EACpB,IAAI2C,WAAW;EACf,IAAItC,SAAS;EACb9G,QAAQ,GAAGmB,YAAY,CAACuF,iBAAiB,CAAC1G,QAAQ,CAAC;EACnD,IAAI4I,KAAK,GAAG,EAAE;EACd,IAAIzK,UAAU,CAACwB,KAAK,CAACJ,MAAM,EAAE;IACzB4B,YAAY,CAACqF,QAAQ,CAACxG,QAAQ,EAAE7B,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EAC3D;EACAK,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;EACxD,OAAOwE,YAAY,CAAC3D,QAAQ,EAAEuD,OAAO,CAAC,EAAE;IACpCkD,gBAAgB,GAAG,IAAIlF,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;IAC/C,KAAK,IAAI6H,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIlL,UAAU,CAACwB,KAAK,CAACJ,MAAM,EAAE8J,CAAC,EAAE,EAAE;MAC/C,KAAK,IAAIrB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAItE,YAAY,CAACnE,MAAM,GAAG,CAAC,EAAEyI,CAAC,EAAE,EAAE;QAC/ChI,QAAQ,GAAGmB,YAAY,CAACuF,iBAAiB,CAAC1G,QAAQ,CAAC;QACnDA,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;QACxDkH,eAAe,GAAG,EAAE;QACpB,OAAOlF,YAAY,CAACwF,UAAU,CAACF,gBAAgB,EAAEzG,QAAQ,CAAC,IACrDwD,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAc,EAAE;UAClF,OAAOrC,YAAY,CAACwF,UAAU,CAACF,gBAAgB,EAAEzG,QAAQ,CAAC,EAAE;YACxDyG,gBAAgB,GAAG,IAAIlF,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;YAC/C,IAAIrD,UAAU,CAACwB,KAAK,CAACJ,MAAM,KAAK,CAAC,IAC5BpB,UAAU,CAACwB,KAAK,CAACJ,MAAM,GAAG,CAAC,IAAIpB,UAAU,CAACwB,KAAK,CAAC6C,QAAQ,CAAC6G,CAAC,CAACzJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAKuB,YAAY,CAAChB,QAAQ,CAACsG,gBAAgB,CAAE,EAAE;cAC3H,IAAIwB,iBAAiB,GAAGvE,YAAY,CAAClB,QAAQ,CAACwF,CAAC,CAACpI,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAACsI,KAAK,CAACC,oBAAoB,CAAC;cAC5F,IAAIC,QAAQ,GAAG5F,QAAQ,CAACyF,iBAAiB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;cACjDmB,WAAW,GAAG,IAAI7H,IAAI,CAACvB,QAAQ,CAACwB,OAAO,CAAC,CAAC,CAAC;cAC1C,OAAOL,YAAY,CAACwF,UAAU,CAACyC,WAAW,EAAEpJ,QAAQ,CAAC,IAC9CmB,YAAY,CAACkH,WAAW,CAACe,WAAW,EAAEpJ,QAAQ,CAAC,EAAE;gBACpD,IAAIiI,iBAAiB,CAACA,iBAAiB,CAAC1I,MAAM,GAAG,CAAC,CAAC,KAAKgD,QAAQ,CAAC6G,WAAW,CAACvF,MAAM,CAAC,CAAC,CAAC,EAAE;kBACpFwC,eAAe,CAACrE,IAAI,CAAC,CAACoH,WAAW,CAAC5H,OAAO,CAAC,CAAC,CAAC,CAAC;gBACjD;gBACA4H,WAAW,CAAChH,OAAO,CAACgH,WAAW,CAAClJ,OAAO,CAAC,CAAC,GAAI,CAAE,CAAC;cACpD;cACAkJ,WAAW,CAAChH,OAAO,CAACgH,WAAW,CAAClJ,OAAO,CAAC,CAAC,GAAI,CAAE,CAAC;cAChD,IAAI+H,iBAAiB,CAAC,CAAC,CAAC,CAAC9E,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE;gBACxC9D,KAAK,GAAGgH,eAAe,CAAC9G,MAAM,GAAI,CAAC,CAAC,GAAG6I,QAAS;cACpD,CAAC,MACI;gBACD/I,KAAK,GAAG+I,QAAQ,GAAG,CAAC;cACxB;cACA/I,KAAK,GAAGiJ,KAAK,CAACjJ,KAAK,CAAC,GAAG,CAAC,GAAGA,KAAK;YACpC;YACAkH,SAAS,GAAGQ,gBAAgB,CAAC/G,QAAQ,EAAE7B,UAAU,EAAEoI,SAAS,EAAEO,SAAS,EAAE,CAAC,CAAC;YAC3E9G,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;UAC5D;QACJ;QACAa,QAAQ,GAAGgI,CAAC,KAAK,CAAC,IAAIoB,WAAW,GAAG,IAAI7H,IAAI,CAAC6H,WAAW,CAAC5H,OAAO,CAAC,CAAC,CAAC,GAAG,IAAID,IAAI,CAACkF,gBAAgB,CAACjF,OAAO,CAAC,CAAC,CAAC;QAC1G,IAAI6E,eAAe,CAAC9G,MAAM,GAAG,CAAC,EAAE;UAC5B,IAAIpC,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;YAC3CqF,iCAAiC,CAACQ,eAAe,EAAE5C,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEkB,KAAK,CAAC;UAC1G,CAAC,MACI;YACDyG,cAAc,GAAG,CAAEyC,2BAA2B,CAAClC,eAAe,EAAEhH,KAAK,EAAEuJ,KAAK,CAAC,CAAE;UACnF;QACJ;QACA,IAAIpF,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,IAAKsB,aAAa,EAAE;UAChF;QACJ;MACJ;IACJ;IACA,IAAI,CAACrG,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;MAC5CgI,mCAAmC,CAAC1C,cAAc,EAAErC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;MAChGyK,KAAK,GAAG,EAAE;IACd;IACA,IAAIzH,YAAY,CAAC+F,WAAW,CAAClH,QAAQ,CAAC,EAAE;MACpCmB,YAAY,CAAC6F,YAAY,CAAChH,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;MACzCA,QAAQ,CAACiH,WAAW,CAACjH,QAAQ,CAACI,WAAW,CAAC,CAAC,GAAGtB,QAAQ,GAAG,CAAC,CAAC;IAC/D,CAAC,MACI;MACDkB,QAAQ,CAACiH,WAAW,CAACjH,QAAQ,CAACI,WAAW,CAAC,CAAC,GAAGtB,QAAQ,CAAC;IAC3D;IACAkB,QAAQ,GAAGyE,mBAAmB,CAACzE,QAAQ,EAAE7B,UAAU,CAACgB,GAAG,CAAC;IACxD,IAAIhB,UAAU,CAACwB,KAAK,CAACJ,MAAM,EAAE;MACzB4B,YAAY,CAACqF,QAAQ,CAACxG,QAAQ,EAAE7B,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,EAAEK,QAAQ,CAACE,OAAO,CAAC,CAAC,CAAC;IAC5E;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoJ,uBAAuBA,CAACjD,eAAe,EAAE3C,YAAY,EAAE;EAC5D,IAAIrE,KAAK;EACT,IAAIkK,0BAA0B,GAAG;IAAElD,eAAe,EAAE,EAAE;IAAEhH,KAAK,EAAE;EAAE,CAAC;EAClE,IAAIqE,YAAY,CAACnE,MAAM,KAAK,CAAC,EAAE;IAC3B;IACA,IAAIiK,kBAAkB,GAAG9F,YAAY,CAAC,CAAC,CAAC,CAACwE,KAAK,CAACC,oBAAoB,CAAC;IACpE,IAAIsB,WAAW,GAAG,KAAK,CAAC;IACxB,IAAID,kBAAkB,CAACjK,MAAM,GAAG,CAAC,EAAE;MAC/BkK,WAAW,GAAGjH,QAAQ,CAACgH,kBAAkB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MACjDnK,KAAK,GAAKoK,WAAW,GAAG,CAAC,GAAKpD,eAAe,CAAC9G,MAAM,GAAGkK,WAAW,GAAIA,WAAW,GAAG,CAAE;IAC1F,CAAC,MACI;MACDpK,KAAK,GAAG,CAAC;MACTgH,eAAe,GAAGqD,gCAAgC,CAACrD,eAAe,CAAC;IACvE;EACJ,CAAC,MACI;IACDhH,KAAK,GAAG,CAAC;IACTgH,eAAe,GAAGqD,gCAAgC,CAACrD,eAAe,CAAC;EACvE;EACAkD,0BAA0B,CAAClD,eAAe,GAAGA,eAAe;EAC5DkD,0BAA0B,CAAClK,KAAK,GAAGA,KAAK;EACxC,OAAOkK,0BAA0B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS/E,oBAAoBA,CAACsB,cAAc,EAAErC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EACvF,IAAIkB,KAAK,GAAKlB,UAAU,CAACqC,WAAW,GAAG,CAAC,GACnCsF,cAAc,CAACvG,MAAM,GAAGpB,UAAU,CAACqC,WAAW,GAAIrC,UAAU,CAACqC,WAAW,GAAG,CAAE;EAClF,IAAIrD,iBAAiB,CAACgB,UAAU,CAACqC,WAAW,CAAC,EAAE;IAC3CnB,KAAK,GAAG,CAAC;IACTyG,cAAc,GAAG4D,gCAAgC,CAAC5D,cAAc,CAAC;EACrE;EACA,IAAIA,cAAc,CAACvG,MAAM,GAAG,CAAC,EAAE;IAC3BsG,iCAAiC,CAACC,cAAc,EAAErC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEkB,KAAK,CAAC;EACzG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASqK,gCAAgCA,CAACrD,eAAe,EAAE;EACvD,IAAIuC,KAAK,GAAG,EAAE;EACd,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGxC,eAAe,CAAC9G,MAAM,EAAEsJ,IAAI,EAAE,EAAE;IACtD,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGzC,eAAe,CAAC7D,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAACL,MAAM,EAAEuJ,GAAG,EAAE,EAAE;MAClFF,KAAK,CAAC5G,IAAI,CAAC,IAAIT,IAAI,CAAC8E,eAAe,CAAC7D,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC4C,QAAQ,CAACsG,GAAG,CAAClJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC4B,OAAO,CAAC,CAAC,CAAC;IAChH;EACJ;EACA6E,eAAe,GAAGuC,KAAK,CAACrJ,MAAM,GAAG,CAAC,GAAG,CAACqJ,KAAK,CAAC,GAAG,EAAE;EACjD,OAAOvC,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0C,gCAAgCA,CAAC1C,eAAe,EAAE1F,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EAC7F,IAAIuF,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC,IAAIsE,KAAK;EACT,IAAImF,KAAK,GAAG,EAAE;EACd,IAAI9C,cAAc,GAAG,EAAE;EACvB,IAAI6D,qBAAqB,GAAGL,uBAAuB,CAACjD,eAAe,EAAE3C,YAAY,CAAC;EAClF2C,eAAe,GAAGsD,qBAAqB,CAACtD,eAAe;EACvD,IAAIhH,KAAK,GAAGsK,qBAAqB,CAACtK,KAAK;EACvC,IAAIlB,UAAU,CAACqC,WAAW,IAAI,IAAI,EAAE;IAChCsF,cAAc,GAAG,CAAEyC,2BAA2B,CAAClC,eAAe,EAAEhH,KAAK,EAAEuJ,KAAK,CAAC,CAAE;IAC/EJ,mCAAmC,CAAC1C,cAAc,EAAErC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,CAAC;EACpG,CAAC,MACI;IACD,IAAIkI,eAAe,CAAC9G,MAAM,GAAG,CAAC,EAAE;MAC5BsG,iCAAiC,CAACQ,eAAe,EAAE5C,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEkB,KAAK,CAAC;IAC1G;EACJ;EACAuJ,KAAK,GAAG,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASL,2BAA2BA,CAAClC,eAAe,EAAEhH,KAAK,EAAEuJ,KAAK,EAAE;EAChE,KAAK,IAAIC,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGxC,eAAe,CAAC7D,QAAQ,CAACnD,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAACL,MAAM,EAAEsJ,IAAI,EAAE,EAAE;IACtFD,KAAK,CAAC5G,IAAI,CAACqE,eAAe,CAAC7D,QAAQ,CAACnD,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC4C,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;EAC9F;EACA,OAAOgJ,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAShD,oBAAoBA,CAACnC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEyL,OAAO,EAAE;EAChF,IAAIpG,aAAa,GAAGJ,YAAY,CAACzC,SAAS,EAAExC,UAAU,CAAC;EACvD,IAAI0L,MAAM,GAAG,IAAItI,IAAI,CAACqI,OAAO,CAAC;EAC9BnG,KAAK,GAAGG,aAAa,CAACiG,MAAM,EAAE1L,UAAU,CAAC;EACzC,IAAK0L,MAAM,IAAIlJ,SAAS,IAAKgD,YAAY,CAACkG,MAAM,EAAEtG,OAAO,CAAC,IAAIE,KAAK,IAC5DD,aAAa,IAAKnC,IAAI,CAAC9B,MAAM,GAAGpB,UAAU,CAAC+D,iBAAiB,GAAIsB,aAAa,EAAE;IAClFR,kBAAkB,CAAC3B,IAAI,EAAEuI,OAAO,CAAC;EACrC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,SAASA,CAACC,IAAI,EAAElJ,cAAc,EAAEwF,eAAe,EAAEwC,IAAI,EAAE1K,UAAU,EAAE;EACxE,IAAI6L,cAAc,GAAGnJ,cAAc,IAAI,CAAC;EACxC,IAAIoJ,YAAY,GAAG,IAAI1I,IAAI,CAACwI,IAAI,EAAE5L,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;EAC7D,IAAIuK,WAAW,GAAG,IAAI3I,IAAI,CAACwI,IAAI,EAAE5L,UAAU,CAACwB,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;EACxD,IAAIwK,mBAAmB,GAAGD,WAAW,CAAChK,OAAO,CAAC,CAAC;EAC/C,IAAIkK,YAAY,GAAG,CAACH,YAAY,CAACpG,MAAM,CAAC,CAAC,GAAGmG,cAAc,GAAG,CAAC,IAAI,CAAC;EACnE,IAAIK,IAAI,GAAGD,YAAY,GAAGD,mBAAmB;EAC7C,IAAItK,KAAK,GAAGwD,IAAI,CAACiH,IAAI,CAACD,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC;EACnC,IAAIT,OAAO,GAAGvD,eAAe,CAAC7D,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC4C,QAAQ,CAAC3C,KAAK,CAACD,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EAC5F,IAAIiK,MAAM,GAAG,IAAItI,IAAI,CAACqI,OAAO,CAAC;EAC9B,IAAInG,KAAK,GAAGG,aAAa,CAACiG,MAAM,EAAE1L,UAAU,CAAC;EAC7C,OAAQsF,KAAK,GAAI5D,KAAK,GAAGA,KAAK,GAAG,CAAC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2I,mCAAmCA,CAACnC,eAAe,EAAE5C,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAE;EACvG,IAAIkI,eAAe,CAAC9G,MAAM,GAAG,CAAC,EAAE;IAC5B,KAAK,IAAIsJ,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGxC,eAAe,CAAC9G,MAAM,EAAEsJ,IAAI,EAAE,EAAE;MACtDxC,eAAe,CAAC7D,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC2K,IAAI,CAAC,CAAC;MACrD,IAAI7G,YAAY,GAAGvF,UAAU,CAACgB,GAAG;MACjC,IAAIwI,cAAc,GAAGjE,YAAY,CAACkE,GAAG,CAAC,UAAUC,IAAI,EAAE;QAAE,OAAOC,SAAS,CAACC,IAAI,CAACF,IAAI,CAAC;MAAE,CAAC,CAAC;MACvF,IAAI2C,SAAS,GAAIrM,UAAU,CAACY,IAAI,KAAK,QAAQ,IAAKZ,UAAU,CAACsM,UAAU,CAACtH,OAAO,CAAC,SAAS,CAAC,GAAG,CAAC,CAAE,IAC5F,EAAEwE,cAAc,CAACxE,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,GACpC2G,SAAS,CAAC,IAAIvI,IAAI,CAAC8E,eAAe,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAACjG,WAAW,CAAC,CAAC,EAAE,CAAC,EAAEiG,eAAe,EAAEwC,IAAI,EAAE1K,UAAU,CAAC,GAC3FkI,eAAe,CAAC7D,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAACL,MAAM,GAAGpB,UAAU,CAACqC,WAAY;MACtF,IAAInB,KAAK,GAAKlB,UAAU,CAACqC,WAAW,GAAG,CAAC,GAAIgK,SAAS,GAAGrM,UAAU,CAACqC,WAAW,GAAG,CAAE;MACnF,IAAIoJ,OAAO,GAAGvD,eAAe,CAAC7D,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC4C,QAAQ,CAACnD,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;MAC5FgG,oBAAoB,CAACnC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEyL,OAAO,CAAC;IAC9E;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS/D,iCAAiCA,CAACQ,eAAe,EAAE5C,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEkB,KAAK,EAAE;EAC5G,IAAIgH,eAAe,CAAC9G,MAAM,GAAG,CAAC,EAAE;IAC5BF,KAAK,GAAG,CAAClC,iBAAiB,CAACkC,KAAK,CAAC,GAAGA,KAAK,GACnClB,UAAU,CAACqC,WAAW,GAAG,CAAC,GACrB6F,eAAe,CAAC9G,MAAM,GAAGpB,UAAU,CAACqC,WAAW,GAAIrC,UAAU,CAACqC,WAAW,GAAG,CAAE;IACzF6F,eAAe,CAAC7D,QAAQ,CAACnD,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC2K,IAAI,CAAC,CAAC;IACtD,KAAK,IAAI1B,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGxC,eAAe,CAAC7D,QAAQ,CAACnD,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAACL,MAAM,EAAEsJ,IAAI,EAAE,EAAE;MACtF,IAAIe,OAAO,GAAGvD,eAAe,CAAC7D,QAAQ,CAACnD,KAAK,CAACO,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC4C,QAAQ,CAACqG,IAAI,CAACjJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;MAC5FgG,oBAAoB,CAACnC,KAAK,EAAE9C,SAAS,EAAE4C,OAAO,EAAElC,IAAI,EAAElD,UAAU,EAAEyL,OAAO,CAAC;IAC9E;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASjG,YAAYA,CAAChD,SAAS,EAAE4C,OAAO,EAAE;EACtC,OAAOA,OAAO,GAAI5C,SAAS,IAAI4C,OAAO,GAAI,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS4F,YAAYA,CAACzF,YAAY,EAAE;EAChC;EACA,IAAIwF,MAAM,GAAGxF,YAAY,CAACgH,OAAO,CAACC,oBAAoB,EAAE,EAAE,CAAC;EAC3D,OAAOzB,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0B,aAAaA,CAACzL,GAAG,EAAEuE,YAAY,EAAE;EACtC,IAAImH,kBAAkB,GAAG,EAAE;EAC3BnH,YAAY,CAACtE,OAAO,CAAC,UAAU0L,OAAO,EAAE;IACpC,IAAIC,uBAAuB,GAAGD,OAAO,CAAC5C,KAAK,CAACC,oBAAoB,CAAC;IACjE,IAAI4C,uBAAuB,CAACxL,MAAM,KAAK,CAAC,EAAE;MACtCsL,kBAAkB,CAAC7I,IAAI,CAAC+I,uBAAuB,CAAC,CAAC,CAAC,CAAC;IACvD,CAAC,MACI;MACDF,kBAAkB,CAAC7I,IAAI,CAAC+I,uBAAuB,CAAC,CAAC,CAAC,CAAC;IACvD;EACJ,CAAC,CAAC;EACF,OAAQF,kBAAkB,CAAC1H,OAAO,CAACZ,QAAQ,CAACC,QAAQ,CAACrD,GAAG,CAACS,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6E,mBAAmBA,CAAC9D,SAAS,EAAE+C,YAAY,EAAE;EAClD,IAAI1D,QAAQ,GAAG,IAAIuB,IAAI,CAACZ,SAAS,CAACa,OAAO,CAAC,CAAC,CAAC;EAC5C,IAAI0H,MAAM;EACV,IAAIxF,YAAY,CAACnE,MAAM,GAAG,CAAC,EAAE;IACzB,IAAIyL,eAAe,GAAG,EAAE;IACxB,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAI3F,YAAY,CAACnE,MAAM,GAAG,CAAC,EAAE8J,CAAC,EAAE,EAAE;MAC/CH,MAAM,GAAGC,YAAY,CAACzF,YAAY,CAAClB,QAAQ,CAAC6G,CAAC,CAACzJ,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;MAC/DoL,eAAe,CAAChJ,IAAI,CAACkH,MAAM,CAAC;IAChC;IACA,IAAI8B,eAAe,CAAC7H,OAAO,CAACZ,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;MAC7D,GAAG;QACC7D,QAAQ,CAACoC,OAAO,CAACpC,QAAQ,CAACE,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC;MAC5C,CAAC,QAAQ8K,eAAe,CAAC7H,OAAO,CAACZ,QAAQ,CAACvC,QAAQ,CAAC6D,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IACxE;EACJ;EACA,OAAO7D,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS5B,qBAAqBA,CAAC6M,KAAK,EAAE;EACzC,IAAI9M,UAAU,GAAG;IACbY,IAAI,EAAE,IAAI;IACVD,QAAQ,EAAE,CAAC;IACXe,KAAK,EAAE,IAAI;IACXE,KAAK,EAAE,IAAI;IACXZ,GAAG,EAAE,EAAE;IACP+E,IAAI,EAAE,IAAI;IACVvE,KAAK,EAAE,EAAE;IACT8F,MAAM,EAAE,EAAE;IACVnF,QAAQ,EAAE,EAAE;IACZyF,OAAO,EAAE,EAAE;IACXvF,WAAW,EAAE,IAAI;IACjBiK,UAAU,EAAE;EAChB,CAAC;EACD,IAAIS,SAAS,GAAGD,KAAK,CAACvJ,KAAK,CAAC,GAAG,CAAC;EAChC,IAAIyJ,SAAS,GAAG,EAAE;EAClB,IAAIC,IAAI;EACRF,SAAS,CAAC9L,OAAO,CAAC,UAAUiC,IAAI,EAAE;IAC9B8J,SAAS,GAAG9J,IAAI,CAACK,KAAK,CAAC,GAAG,CAAC;IAC3B,QAAQyJ,SAAS,CAAC,CAAC,CAAC;MAChB,KAAK,OAAO;QACRC,IAAI,GAAGD,SAAS,CAAC,CAAC,CAAC;QACnBhN,UAAU,CAAC4B,KAAK,GAAG+B,+BAA+B,CAACsJ,IAAI,CAAC;QACxD;MACJ,KAAK,OAAO;QACRjN,UAAU,CAACgB,GAAG,GAAGgM,SAAS,CAAC,CAAC,CAAC,CAACzJ,KAAK,CAAC,GAAG,CAAC;QACxCvD,UAAU,CAACsM,UAAU,CAACzI,IAAI,CAACmJ,SAAS,CAAC,CAAC,CAAC,CAAC;QACxC;MACJ,KAAK,YAAY;QACbhN,UAAU,CAACmC,QAAQ,GAAG6K,SAAS,CAAC,CAAC,CAAC,CAACzJ,KAAK,CAAC,GAAG,CAAC,CAACkG,GAAG,CAACyD,MAAM,CAAC;QACzDlN,UAAU,CAACsM,UAAU,CAACzI,IAAI,CAACmJ,SAAS,CAAC,CAAC,CAAC,CAAC;QACxC;MACJ,KAAK,SAAS;QACVhN,UAAU,CAACwB,KAAK,GAAGwL,SAAS,CAAC,CAAC,CAAC,CAACzJ,KAAK,CAAC,GAAG,CAAC,CAACkG,GAAG,CAACyD,MAAM,CAAC;QACtDlN,UAAU,CAACsM,UAAU,CAACzI,IAAI,CAACmJ,SAAS,CAAC,CAAC,CAAC,CAAC;QACxC;MACJ,KAAK,WAAW;QACZhN,UAAU,CAAC4H,OAAO,GAAGoF,SAAS,CAAC,CAAC,CAAC,CAACzJ,KAAK,CAAC,GAAG,CAAC,CAACkG,GAAG,CAACyD,MAAM,CAAC;QACxDlN,UAAU,CAACsM,UAAU,CAACzI,IAAI,CAACmJ,SAAS,CAAC,CAAC,CAAC,CAAC;QACxC;MACJ,KAAK,UAAU;QACXhN,UAAU,CAACsH,MAAM,GAAG0F,SAAS,CAAC,CAAC,CAAC,CAACzJ,KAAK,CAAC,GAAG,CAAC,CAACkG,GAAG,CAACyD,MAAM,CAAC;QACvDlN,UAAU,CAACsM,UAAU,CAACzI,IAAI,CAACmJ,SAAS,CAAC,CAAC,CAAC,CAAC;QACxC;MACJ,KAAK,UAAU;QACXhN,UAAU,CAACW,QAAQ,GAAG0D,QAAQ,CAAC2I,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QAChD;MACJ,KAAK,OAAO;QACRhN,UAAU,CAAC0B,KAAK,GAAG2C,QAAQ,CAAC2I,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QAC7C;MACJ,KAAK,UAAU;QACXhN,UAAU,CAACqC,WAAW,GAAGgC,QAAQ,CAAC2I,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG3I,QAAQ,CAAC2I,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACzF;MACJ,KAAK,MAAM;QACPhN,UAAU,CAACY,IAAI,GAAGoM,SAAS,CAAC,CAAC,CAAC;QAC9B;MACJ,KAAK,MAAM;QACPhN,UAAU,CAAC+F,IAAI,GAAGiH,SAAS,CAAC,CAAC,CAAC;QAC9B;IACR;EACJ,CAAC,CAAC;EACF,IAAKhN,UAAU,CAACY,IAAI,KAAK,SAAS,IAAMZ,UAAU,CAACmC,QAAQ,CAACf,MAAM,KAAK,CAAE,EAAE;IACvE,IAAIF,KAAK,GAAGlB,UAAU,CAACsM,UAAU,CAACtH,OAAO,CAAC,OAAO,CAAC;IAClDhF,UAAU,CAACsM,UAAU,CAACa,MAAM,CAACjM,KAAK,EAAE,CAAC,CAAC;EAC1C;EACA,OAAOlB,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmJ,kBAAkBA,CAACtH,QAAQ,EAAEqB,IAAI,EAAEV,SAAS,EAAE;EACnD,IAAI+E,OAAO,GAAGvE,YAAY,CAACgG,iBAAiB,CAACnH,QAAQ,CAAC;EACtD,OAAQqB,IAAI,IAAIqE,OAAO,IAAM1F,QAAQ,IAAIW,SAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS+H,eAAeA,CAAChF,YAAY,EAAE;EACnC,IAAI6H,QAAQ,GAAG,CAAC,CAAC;EACjB7H,YAAY,CAACtE,OAAO,CAAC,UAAU0L,OAAO,EAAEzL,KAAK,EAAE;IAC3C,IAAIA,KAAK,KAAKqE,YAAY,CAACnE,MAAM,GAAG,CAAC,EAAE;MACnC,IAAIiM,UAAU,GAAGrH,QAAQ,CAAChB,OAAO,CAAC2H,OAAO,CAAC;MAC1C,IAAIM,IAAI,GAAGI,UAAU;MACrB,OAAOJ,IAAI,GAAG,CAAC,KAAKjH,QAAQ,CAAChB,OAAO,CAACO,YAAY,CAAC,CAAC,CAAC,CAAC,EAAE;QACnD0H,IAAI,EAAE;MACV;MACAG,QAAQ,CAAC,EAAE,GAAGT,OAAO,CAAC,GAAGM,IAAI,GAAGI,UAAU;IAC9C,CAAC,MACI;MACDD,QAAQ,CAAC,EAAE,GAAGT,OAAO,CAAC,GAAG3G,QAAQ,CAAChB,OAAO,CAACO,YAAY,CAAErE,KAAK,GAAG,CAAC,CAAE,CAAC,GAAG8E,QAAQ,CAAChB,OAAO,CAAC2H,OAAO,CAAC;IACpG;EACJ,CAAC,CAAC;EACF,OAAOS,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,SAASA,CAACzL,QAAQ,EAAE0L,YAAY,EAAE;EACvC,IAAIN,IAAI,GAAGM,YAAY,CAACC,KAAK,CAAC,CAAC,CAAC;EAChC,IAAItK,IAAI;EACR,IAAIqE,OAAO,GAAGvE,YAAY,CAACgG,iBAAiB,CAACnH,QAAQ,CAAC;EACtDqB,IAAI,GAAG+J,IAAI,CAACQ,KAAK,CAAC,CAAC;EACnB,OAAOvK,IAAI,EAAE;IACT,IAAIA,IAAI,GAAG,CAAC,EAAE;MACVA,IAAI,GAAGA,IAAI,GAAGqE,OAAO,GAAG,CAAC;IAC7B;IACA,IAAIrE,IAAI,KAAKrB,QAAQ,CAACE,OAAO,CAAC,CAAC,EAAE;MAC7B,OAAO,KAAK;IAChB;IACAmB,IAAI,GAAG+J,IAAI,CAACQ,KAAK,CAAC,CAAC;EACvB;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAAC7L,QAAQ,EAAE8L,eAAe,EAAE;EAC1C,IAAIV,IAAI,GAAGU,eAAe,CAACH,KAAK,CAAC,CAAC,CAAC;EACnC,IAAItK,IAAI;EACR,IAAI0E,OAAO,GAAGgG,UAAU,CAAC/L,QAAQ,CAAC;EAClCqB,IAAI,GAAG+J,IAAI,CAACQ,KAAK,CAAC,CAAC;EACnB,OAAOvK,IAAI,EAAE;IACT,IAAIA,IAAI,GAAG,CAAC,EAAE;MACVA,IAAI,GAAGA,IAAI,GAAGF,YAAY,CAAC+E,gBAAgB,CAAClG,QAAQ,EAAE,CAAC,CAAC,GAAG,CAAC;IAChE;IACA,IAAIqB,IAAI,KAAK0E,OAAO,EAAE;MAClB,OAAO,KAAK;IAChB;IACA1E,IAAI,GAAG+J,IAAI,CAACQ,KAAK,CAAC,CAAC;EACvB;EACA,OAAO,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,UAAUA,CAAC3C,WAAW,EAAE;EAC7B,IAAI,CAAC4C,mBAAmB,CAAC7K,YAAY,CAACf,WAAW,CAACgJ,WAAW,CAAC,CAAC,EAAE;IAC7D4C,mBAAmB,CAAC7K,YAAY,CAACf,WAAW,CAACgJ,WAAW,CAAC,CAAC,GAAGjI,YAAY,CAACkE,eAAe,CAAC+D,WAAW,EAAE,CAAC,CAAC;EAC7G;EACA,IAAIpJ,QAAQ,GAAGgM,mBAAmB,CAAC7K,YAAY,CAACf,WAAW,CAACgJ,WAAW,CAAC,CAAC;EACzE,IAAI6C,IAAI,GAAG7C,WAAW,CAAC5H,OAAO,CAAC,CAAC,GAAGxB,QAAQ,CAACwB,OAAO,CAAC,CAAC;EACrD,OAAO6B,IAAI,CAACiH,IAAI,CAAC2B,IAAI,GAAG1O,UAAU,CAAC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoH,uBAAuBA,CAACxG,UAAU,EAAE;EACzC,IAAIA,UAAU,CAACmC,QAAQ,CAACf,MAAM,IAAI,CAACpB,UAAU,CAACgB,GAAG,CAACI,MAAM,EAAE;IACtD,OAAO,MAAM;EACjB,CAAC,MACI,IAAI,CAACpB,UAAU,CAACmC,QAAQ,CAACf,MAAM,IAAIpB,UAAU,CAACgB,GAAG,CAACI,MAAM,EAAE;IAC3D,OAAO,KAAK;EAChB;EACA,OAAO,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2M,MAAMA,CAACC,IAAI,EAAE;EAClB,IAAI9K,IAAI,GAAG8K,IAAI,CAACP,KAAK,CAAC,CAAC;EACvBO,IAAI,CAACnK,IAAI,CAACX,IAAI,CAAC;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiB,iBAAiBA,CAACnD,GAAG,EAAE;EAC5B,OAAOgF,QAAQ,CAAC,CAAC,CAAC,KAAKhF,GAAG,EAAE;IACxB+M,MAAM,CAAC/H,QAAQ,CAAC;EACpB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASP,aAAaA,CAAC5D,QAAQ,EAAE7B,UAAU,EAAE;EACzC,IAAIsF,KAAK,GAAG,IAAI;EAChB,IAAIC,YAAY,GAAGvF,UAAU,CAACgB,GAAG;EACjC,IAAIiN,aAAa,GAAGjO,UAAU,CAACwB,KAAK;EACpC,IAAI+L,YAAY,GAAGvK,YAAY,CAACkL,eAAe,CAACrM,QAAQ,EAAE7B,UAAU,CAACmC,QAAQ,CAAC;EAC9E,IAAIwL,eAAe,GAAG3N,UAAU,CAAC4H,OAAO;EACxC5H,UAAU,CAACsM,UAAU,CAACrL,OAAO,CAAC,UAAUrB,IAAI,EAAE;IAC1C,QAAQA,IAAI;MACR,KAAK,OAAO;QACR,IAAI6M,aAAa,CAAC5K,QAAQ,CAAC6D,MAAM,CAAC,CAAC,EAAEH,YAAY,CAAC,EAAE;UAChDD,KAAK,GAAG,KAAK;QACjB;QACA;MACJ,KAAK,SAAS;QACV,IAAItC,YAAY,CAACyF,UAAU,CAAC5G,QAAQ,EAAEoM,aAAa,CAAC,EAAE;UAClD3I,KAAK,GAAG,KAAK;QACjB;QACA;MACJ,KAAK,YAAY;QACb,IAAIgI,SAAS,CAACzL,QAAQ,EAAE0L,YAAY,CAAC,EAAE;UACnCjI,KAAK,GAAG,KAAK;QACjB;QACA;MACJ,KAAK,WAAW;QACZ,IAAIoI,SAAS,CAAC7L,QAAQ,EAAE8L,eAAe,CAAC,EAAE;UACtCrI,KAAK,GAAG,KAAK;QACjB;QACA;IACR;EACJ,CAAC,CAAC;EACF,OAAOA,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASrC,eAAeA,CAAC1C,YAAY,EAAE;EAC1C,IAAIA,YAAY,KAAK,SAAS,EAAE;IAC5B,OAAO,IAAIf,OAAO,CAAC,CAAC;EACxB;EACA,OAAO,IAAIC,SAAS,CAAC,CAAC;AAC1B;AACA,IAAIoO,mBAAmB,GAAG,CAAC,CAAC;AAC5B,IAAIvK,eAAe;AACnB,IAAI0C,QAAQ,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AACzD,IAAI9B,aAAa;AACjB,IAAIF,YAAY;AAChB,IAAIhB,YAAY;AAChB,IAAIoB,QAAQ,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;AACzD,IAAItB,aAAa,GAAG,EAAE;AACtB,IAAIR,OAAO,GAAG,CAAC,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,CAAC;AAC5D,IAAIX,KAAK,GAAG,cAAc;AAC1B,IAAIZ,EAAE,GAAG,WAAW;AACpB,IAAIX,KAAK,GAAG,OAAO;AACnB,IAAI0B,KAAK,GAAG,cAAc;AAC1B,IAAIjB,IAAI,GAAG,YAAY;AACvB,IAAIC,KAAK,GAAG,aAAa;AACzB,IAAIO,MAAM,GAAG,cAAc;AAC3B,IAAIE,KAAK,GAAG,aAAa;AACzB,IAAIJ,cAAc,GAAG;EACjBgN,EAAE,EAAE,KAAK;EACTC,EAAE,EAAE,KAAK;EACTC,EAAE,EAAE,KAAK;EACTC,EAAE,EAAE,KAAK;EACTC,EAAE,EAAE,KAAK;EACTC,EAAE,EAAE,KAAK;EACTC,EAAE,EAAE;AACR,CAAC;AACD;AACA,IAAI9E,SAAS,GAAG,IAAI;AACpB;AACA,IAAI6C,oBAAoB,GAAG,SAAS;AACpC;AACA,IAAIxC,oBAAoB,GAAG,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS0E,2BAA2BA,CAAC5J,IAAI,EAAE;EAC9C,OAAO,CAACA,IAAI,CAAC6J,cAAc,CAAC,CAAC,EACzBC,eAAe,CAAC9J,IAAI,CAAC+J,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,EACvCD,eAAe,CAAC9J,IAAI,CAACgK,UAAU,CAAC,CAAC,CAAC,EAClC,GAAG,EACHF,eAAe,CAAC9J,IAAI,CAACiK,WAAW,CAAC,CAAC,CAAC,EACnCH,eAAe,CAAC9J,IAAI,CAACkK,aAAa,CAAC,CAAC,CAAC,EACrCJ,eAAe,CAAC9J,IAAI,CAACmK,aAAa,CAAC,CAAC,CAAC,EACrC,GAAG,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASN,eAAeA,CAAC9J,IAAI,EAAE;EAC3B,OAAO,CAAC,GAAG,GAAGA,IAAI,EAAE0I,KAAK,CAAC,CAAC,CAAC,CAAC;AACjC"},"metadata":{},"sourceType":"module"}